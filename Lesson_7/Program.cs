
namespace Lesson7
{
    public static class Program
    {
        static void Main()
        {
            //// v1
            //var user1 = new User("Vasya", "test1@gmail.com");
            //try
            //{
            //    Console.WriteLine(user1.Name);
            //}
            //finally
            //{
            //    user1.Dispose();
            //}

            //// v2
            //using(var user2 = new User("Petya", "test2@gmail.com"))
            //{
            //    Console.WriteLine(user2.Name);
            //}

            //// v3
            //using var user3 = new User("Anton", "test3@gmail.com");

            //Console.WriteLine(user3.Name);
            //Console.WriteLine(user3.Email);

            //// v4
            //using (var user4 = new User("Petya1", "test21@gmail.com"))
            //{
            //    using (var user5 = new User("Petya2", "test22@gmail.com"))
            //    {
            //        Console.WriteLine(user5.Name);
            //    }
            //    Console.WriteLine(user4.Name);
            //}

            // v5
            //using var user4 = new User("Petya1", "test21@gmail.com");
            //using (var user5 = new User("Petya2", "test22@gmail.com"))
            //{
            //    Console.WriteLine(user5.Name);
            //}
            //Console.WriteLine(user4.Name);


            //var user2 = new User("Vasya", "test2@gmail.com");
            //Console.WriteLine(user1.Name);

            // unsafe code

            //unsafe
            //{
            //    //int numbers = 10; // обычная переменная
            //    //int* number_ptr = &numbers; // указатель на переменную типа int (хранит адрес другой переменной)
            //    //// &numbers -> операция взятия адреса переменной
            //    //Console.WriteLine(*number_ptr); // *number_ptr -> разыменование - получение значения по адресу

            //    //
            //    //int age = 30;
            //    //Console.WriteLine(age);
            //    //int* age_ptr = &age;
            //    //*age_ptr += 10;
            //    //Console.WriteLine(age);

            //    ////
            //    //int** new_age_ptr = &age_ptr;
            //    //Console.WriteLine(**new_age_ptr);
            //}
        }
    }
}


///////


//namespace Lesson7
//{
//    public class MyArray : IDisposable
//    {
//        private FileStream? _fileStream; // a file handle

//        public MyArray(string filePath)
//        {
//            _fileStream = new FileStream(filePath, FileMode.OpenOrCreate);
//        }

//        // implement the IDisposable interface
//        public void Dispose()
//        {
//            // dispose of any managed resources here
//            if (_fileStream != null)
//            {
//                _fileStream.Dispose();
//                _fileStream = null;
//            }
//        }
//    }

//    public static class Program
//    {
//        static void Main(string[] args)
//        {
//            string filePath = "example.txt";
//            using (MyArray myArray = new MyArray(filePath))
//            {
//                // perform operations on myArray object here
//            }
//        }
//    }
//}

// При використанні типів посилань, наприклад, об'єктів класів, для них буде відводитися місце в стеку,
// тільки там буде зберігатися не значення, а адреса на ділянку пам'яті в хіпі або купі,
// в якому і будуть знаходитися самі значення даного об'єкта. І якщо об'єкт класу перестає використовуватися,
// то при очищенні стека посилання на ділянку пам'яті також очищається,
// проте це не призводить до негайного очищення ділянки пам'яті в купі.
// Згодом збирач сміття (garbage collector) побачить, що на цю ділянку пам'яті більше немає посилань і очистить її.

// наприклад:

//Test();

//void Test()
//{
//    Person tom = new Person("Tom");
//    Console.WriteLine(tom.Name);
//}
//record class Person(string Name);

// У методі Test створюється об'єкт Person. За допомогою оператора new у купі для зберігання об'єкта CLR виділяє ділянку пам'яті.
// А в стек додає адресу на цю ділянку пам'яті. У неявно визначеному методі Main ми викликаємо метод Test.
// І після того, як Test відпрацює, місце в стеку очищається,
// а збирач сміття очищає раніше виділену під зберігання об'єкта Person ділянку пам'яті.

// Складальник сміття не запускається відразу після видалення стека посилання на об'єкт, розміщений у купі.
// Він запускається в той час, коли середовище CLR виявить потребу, наприклад, коли програмі потрібна додаткова пам'ять.

// Як правило, об'єкти в купі розташовуються невпорядковано, між ними можуть бути порожнечі.
// Купа досить сильно фрагментована. Тому після очищення пам'яті в результаті чергового складання сміття об'єкти,
// що залишилися, переміщаються в один безперервний блок пам'яті. Разом з цим відбувається оновлення посилань,
// щоб правильно вказувати на нові адреси об'єктів.

// Також слід зазначити, що з великих об'єктів існує своя купа - Large Object Heap.
// У цю купу розміщуються об'єкти, розмір яких більше 85 000 байт.
// Особливість цієї купи полягає в тому, що при складанні сміття стиснення пам'яті не проводиться через великі витрати,
// пов'язані з розміром об'єктів.

// Незважаючи на те, що на стиснення зайнятого простору потрібен час, та й додаток не зможе продовжувати роботу,
// поки не відпрацює збирач сміття, проте завдяки подібному підходу також відбувається оптимізація програми.
// Тепер, щоб знайти вільне місце в купі середовищі CLR не потрібно шукати острівці порожнього простору серед зайнятих блоків.
// Їй достатньо звернутися до покажчика купи, який вказує на вільну ділянку пам'яті, що зменшує кількість звернень до пам'яті.

// Крім того, щоб знизити витрати від роботи збирача сміття, всі об'єкти в купі поділяються на покоління.
// Усього існує три покоління об'єктів: 0, 1 та 2-ге.

// До покоління 0 належать нові об'єкти, які ще жодного разу не піддавалися збиранню сміття.
// До покоління 1 відносяться об'єкти, які пережили одну збірку, а до покоління 2 - об'єкти, що пройшли більше одного складання сміття.

// Коли збирач сміття починає роботу, він спочатку аналізує об'єкти з покоління 0.
// Ті об'єкти, які залишаються актуальними після очищення, підвищуються до покоління 1.

// Якщо після обробки об'єктів покоління 0 досі необхідна додаткова пам'ять, то збирач сміття приступає до об'єктів з покоління 1.
// Ті об'єкти, на які вже немає посилань, знищуються, а ті, які, як і раніше, актуальні, підвищуються до покоління 2.

// Оскільки об'єкти з покоління 0 є молодшими і часто перебувають у адресному просторі пам'яті поруч друг з одним,
// їх видалення проходить із найменшими витратами.

///// Клас System.GC

// Функціонал збирача сміття у бібліотеці класів .NET представляє клас System.GC.
// Через статичні методи цей клас дозволяє звертатися до збирача сміття. Як правило, потреба у застосуванні цього класу відсутня.
// Найбільш поширеним випадком його використання є складання сміття при роботі з некерованими ресурсами,
// при інтенсивному виділенні великих обсягів пам'яті, при яких необхідне таке ж швидке звільнення.

// Розглянемо деякі методи та властивості класу System.GC:

// Метод AddMemoryPressure інформує середовище CLR про виділення великого обсягу некерованої пам'яті,
// яку слід врахувати під час планування складання сміття. У зв'язку з цим методом використовується метод RemoveMemoryPressure,
// який вказує на CLR, що раніше виділена пам'ять звільнена, і її не треба враховувати при складання сміття.

// Метод Collect приводить у дію механізм складання сміття.
// Перевантажені версії методу дозволяють вказати покоління об'єктів, аж до якого треба зробити сміття.

// Метод GetGeneration(Object) дозволяє визначити номер покоління, до якого належить переданий як параметр об'єкт

// Метод GetTotalMemory повертає обсяг пам'яті в байтах, яке зайняте в купі, що керується.

// Метод WaitForPendingFinalizers припиняє роботу поточного потоку до звільнення всіх об'єктів, для яких здійснюється складання сміття

// приклад:

//long totalMemory = GC.GetTotalMemory(false);
//Console.WriteLine(totalMemory);

//int number = 1000;
//totalMemory = GC.GetTotalMemory(false);
//Console.WriteLine(totalMemory);

//GC.Collect();
//GC.WaitForPendingFinalizers();

//
// За допомогою перевантажених версій методу GC.Collect можна виконати більш точне налаштування складання сміття.
// Так, його перевантажена версія приймає як параметр число - номер покоління, до якого треба виконати очищення.
// Наприклад, GC.Collect(0) - видаляються лише об'єкти покоління 0.

// Ще одна перевантажена версія приймає ще й другий параметр – перерахування GCCollectionMode. Цей перелік може набувати трьох значень:

// Default: значення за промовчанням для цього переліку (Forced)

// Forced: викликає негайне виконання складання сміття

// Optimized: дозволяє збирачеві сміття визначити, чи є поточний момент оптимальним для збирання сміття

// Наприклад, негайне складання сміття до першого покоління об'єктів: GC.Collect(1, GCCollectionMode.Forced);

//////
// Більшість об'єктів, що використовуються в програмах на C#, відносяться до керованого або managed-коду.
// Такі об'єкти управляються CLR і легко очищаються збирачем сміття.
// Однак разом з тим зустрічаються також такі об'єкти,
// які задіяють некеровані об'єкти (підключення до файлів, баз даних, мережеві підключення і т.д.).
// Такі некеровані об'єкти звертаються до операційної системи API.
// Складальник сміття може впоратися з керованими об'єктами, однак він не знає, як видаляти некеровані об'єкти.
// І тут розробник повинен сам реалізовувати механізми очищення лише на рівні програмного коду.

// Звільнення некерованих ресурсів передбачає реалізацію одного з двох механізмів:

// Створення деструктора

// Реалізація класом інтерфейсу System.IDisposable

// Створення деструкторів
// Якщо ви раптом програмували мовою C++, то, напевно, вже знайомі з концепцією деструкторів.
// Метод деструктора має ім'я класу (як і конструктор), перед яким стоїть знак тильди (~).

// Деструктори можна визначити лише у класах.
// Деструктор на відміну від конструктора не може мати модифікаторів доступу та параметри.
// При цьому кожен клас може мати лише один деструктор.

//class Person
//{
//    public string Name { get; }
//    public Person(string name) => Name = name;

//    ~Person()
//    {
//        Console.WriteLine($"{Name} has deleted");
//    }
//}

// В даному випадку в деструкторі з метою демонстрації просто виводиться рядок на консоль, що повідомляє, що об'єкт видалено.
// Але в реальних програмах деструктор вкладається логіка звільнення некерованих ресурсів.

// Однак насправді при очищенні збирач сміття викликає не деструктор, а метод Finalize.
// Все тому, що компілятор C# компілює деструктор у конструкцію, яка еквівалентна наступній:

//protected override void Finalize()
//{
//    try
//    {
//        // тут інструкції деструктора
//    }
//    finally
//    {
//        base.Finalize();
//    }
//}

// Метод Finalize вже визначений у базовому для всіх типів класі Object, проте цей метод не можна просто перевизначити.
// І фактична його реалізація відбувається через створення деструктора.

//Test();
//GC.Collect();   // очищення пам'яті під об'єкт tom
//Console.Read();

//void Test()
//{
//    Person tom = new Person("Tom");
//}

//public class Person
//{
//    public string Name { get; }
//    public Person(string name) => Name = name;

//    ~Person()
//    {
//        Console.WriteLine($"{Name} has been deleted");
//    }
//}

// Зверніть увагу, що навіть після завершення методу Test і відповідно видалення з стека посилання на об'єкт Person у купі,
// може не наслідувати негайний виклик деструктора.
// Тільки після завершення всієї програми гарантовано відбудеться очищення пам'яті.
// Однак з .NET 5 та в наступних версіях при завершенні програми деструктори не викликаються.
// Тому в програмі вище для швидшого очищення пам'яті застосовується метод GC.Collect
// і для гарантованого виклику деструктора встановлюється затримка за допомогою виклику Console.Read(),
// який очікує від користувача введення.

// На рівні пам'яті це виглядає так: збирач сміття при розміщенні об'єкта в купі визначає, чи підтримує даний об'єкт метод Finalize.
// І якщо об'єкт має метод Finalize, то покажчик на нього зберігається у спеціальній таблиці, що називається черга фіналізації.
// Коли настає момент складання сміття, збирач бачить, що даний об'єкт повинен бути знищений, і якщо він має метод Finalize,
// він копіюється в ще одну таблицю і остаточно знищується лише при наступному проході збирача сміття.

// Точний час виклику деструктора не визначено.
// Крім того, під час фіналізації двох пов'язаних об'єктів порядок виклику деструкторів не гарантується.
// Тобто якщо об'єкт A зберігає посилання на об'єкт B, і при цьому обидва ці об'єкти мають деструктори,
// то для об'єкта B деструктор може вже відпрацювати в той час, як для об'єкта A деструктор тільки почне роботу.

// І тут ми можемо зіткнутися з наступною проблемою: а якщо нам негайно треба викликати деструктор
// і звільнити всі пов'язані з об'єктом некеровані ресурси? У цьому випадку ми можемо використовувати
// другий підхід - реалізацію інтерфейсу IDisposable.

/// Интерфейс IDisposable
/// 
//Test();

//void Test()
//{
//    Person? tom = null;
//    try
//    {
//        tom = new Person("Tom");
//    }
//    finally
//    {
//        tom?.Dispose();
//    }
//}

//public class Person : IDisposable
//{
//    public string Name { get; }
//    public Person(string name) => Name = name;

//    public void Dispose()
//    {
//        Console.WriteLine($"{Name} has been disposed");
//    }
//}

///
// Ми розглянули два підходи. Який із них кращий? З одного боку,
// метод Dispose дозволяє будь-якої миті часу викликати звільнення пов'язаних ресурсів, з другого - програміст,
// використовує наш клас, може забути поставити в коді виклик методу Dispose. Загалом бувають різні ситуації.
// І щоб поєднувати плюси обох підходів, ми можемо використовувати комбінований підхід.
// Microsoft пропонує нам використовувати наступний формалізований шаблон:

//public class SomeClass : IDisposable
//{
//    private bool disposed = false;

//    // реалізація інтерфейсу IDisposable.
//    public void Dispose()
//    {
//        // звільняємо некеровані ресурси
//        Dispose(true);
//        // пригнічуємо фіналізацію
//        GC.SuppressFinalize(this);
//    }

//    protected virtual void Dispose(bool disposing)
//    {
//        if (disposed) return;
//        if (disposing)
//        {
//            // Звільняємо керовані ресурси
//        }
//        // звільняємо некеровані об'єкти
//        disposed = true;
//    }

//    // Деструктор
//    ~SomeClass()
//    {
//        Dispose(false);
//    }
//}

//Логіка очищення реалізується перевантаженою версією методу Dispose (bool disposing).
//Якщо параметр disposing має значення true, цей метод викликається з громадського методу Dispose, якщо false - те з деструктора.

//При виклику деструктора як параметр disposing передається значення false,
//щоб уникнути очищення керованих ресурсів, оскільки ми можемо бути впевненими у тому стані,
//що вони досі перебувають у пам'яті. І тут залишається покладатися на деструктори цих ресурсів.
//Та й в обох випадках звільняються некеровані ресурси.

//Ще один важливий момент - виклик у методі Dispose методу GC.SuppressFinalize(this).
//GC.SuppressFinalize не дозволяє системі виконати метод Finalize для цього об'єкта.
//Якщо ж у класі деструктор не визначено, то виклик цього методу не матиме жодного ефекту.

//Таким чином, навіть якщо розробник не використовує у програмі метод Dispose, все одно відбудеться очищення та звільнення ресурсів.

// Загальні рекомендації щодо використання Finalize та Dispose

//Деструктор слід реалізовувати тільки в тих об'єктів, яким він дійсно необхідний, оскільки метод Finalize дуже впливає на продуктивність.

//Після виклику методу Dispose необхідно блокувати у об'єкта виклик методу Finalize за допомогою GC.SuppressFinalize

//При створенні похідних класів від базових, які реалізують інтерфейс IDisposable, слід також викликати метод Dispose базового класу:

//public class Base : IDisposable
//{
//    public virtual void Dispose()
//    {
//        //
//    }
//}

//public class Derived : Base
//{
//    private bool IsDisposed = false;

//    public override void Dispose()
//    {
//        if (IsDisposed) return;
//        IsDisposed = true;
//        // Звернення до методу Dispose базового класу
//        base.Dispose();
//    }
//}

// Віддавайте перевагу комбінованому шаблону, що реалізує як метод Dispose, так і деструктор

