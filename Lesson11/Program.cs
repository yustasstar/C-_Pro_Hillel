//Одним із ключових аспектів у сучасному програмуванні є багатопоточність.
//Ключовим поняттям під час роботи з многоопоточностью є потік.
//Потік є деякою частиною коду програми.
//За виконання програми кожному потоку виділяється певний квант часу.
//І за допомогою багатопоточності ми можемо виділити в додатку кілька потоків,
//які виконуватимуть різні завдання одночасно. Якщо у нас, припустимо, графічний додаток,
//який посилає запит до якогось сервера або зчитує та обробляє величезний файл,
//то без багатопоточності у нас блокувався б графічний інтерфейс на час виконання завдання.
//А завдяки потокам ми можемо виділити відправку запиту або будь-яке інше завдання,
//яке може довго оброблятись, в окремий потік.
//Тому, наприклад, клієнт-серверні додатки (і не тільки вони) мало мислимі без багатопоточності.

//Основний функціонал використання потоків у додатку зосереджений у просторі імен System.Threading .
//У ньому визначено клас, що представляє окремий потік - клас Thread .

//Клас Thread визначає ряд методів та властивостей,
//які дозволяють керувати потоком та отримувати інформацію про нього. Основні властивості класу:

//ExecutionContext: дозволяє отримати контекст, у якому виконується потік

//IsAlive : вказує, чи потік працює в даний момент

//IsBackground : вказує, чи потік є фоновим

//Name : містить ім'я потоку

//ManagedThreadId : повертає числовий ідентифікатор поточного потоку

//Priority : зберігає пріоритет потоку - значення перерахування ThreadPriority :

//Найнижчий

//Нижче нормального

//нормальний

//Вище нормального

//Найвищий

//За промовчанням потоку задається значення Normal.
//Проте ми можемо змінити пріоритет у процесі роботи програми.
//Наприклад, підвищити важливість потоку, встановивши пріоритет Highest.
//Середовище CLR зчитуватиме та аналізуватиме значення пріоритету
//та на їх підставі виділятиме цьому потоку ту чи іншу кількість часу.

//ThreadState повертає стан потоку - одне із значень перерахування ThreadState :

//Aborted: потік зупинено, але поки що остаточно не завершено

//AbortRequested : для потоку викликаний метод Abort, але зупинка потоку ще не відбулася

//Background : потік виконується у фоновому режимі

//Running : потік запущений і працює (не призупинено)

//Stopped: потік завершений

//StopRequested: потік отримав запит на зупинку

//Suspended : потік припинений

//SuspendRequested : потік отримав запит на призупинення

//Unstarted : потік ще не був запущений

//WaitSleepJoin : потік заблокований в результаті дії методів Sleep або Join

//У процесі роботи потоку його статус багаторазово може змінитися під впливом методів.
//Так, на початку ще до застосування методу Start його статус має значення Unstarted.
//Запустивши потік, змінимо його статус на Running. Викликавши метод Sleep, статус зміниться на WaitSleepJoin.

//Крім того, статична властивість CurrentThread класу Thread дозволяє отримати поточний потік

//У програмі на C# є щонайменше один потік - головний потік, у якому виконується метод Main.

//Наприклад, використовуємо вищеописані властивості для отримання інформації про потік:

//using System.Text;
//using System.Threading;

//Console.OutputEncoding = System.Text.Encoding.UTF8;
//// получаем текущий поток
//Thread currentThread = Thread.CurrentThread;

////получаем имя потока
//Console.WriteLine($"Имя потока: {currentThread.Name}");
//currentThread.Name = "Метод Main";
//Console.WriteLine($"Имя потока: {currentThread.Name}");

//Console.WriteLine($"Запущен ли поток: {currentThread.IsAlive}");
//Console.WriteLine($"Id потока: {currentThread.ManagedThreadId}");
//Console.WriteLine($"Приоритет потока: {currentThread.Priority}");
//Console.WriteLine($"Статус потока: {currentThread.ThreadState}");

//Так як за умовчанням властивість Name у об'єктів Thread не встановлено,
//то в першому випадку ми отримуємо значення цієї властивості порожній рядок.

//Також клас Thread визначає низку методів для управління потоком. Основні з них:

//Статичний метод GetDomain повертає посилання на домен програми

//Статичний метод GetDomainID повертає id домену програми, в якій виконується поточний потік

//Статичний метод Sleep зупиняє потік на певну кількість мілісекунд

//Метод Interrupt перериває потік, який перебуває у стані WaitSleepJoin

//Метод Join блокує виконання потоку, що викликав його доти,
//поки не завершиться потік, для якого був викликаний даний метод

//Метод Start запускає потік

//Наприклад, застосуємо метод Sleep для завдання затримки виконання програми:

//using System.Threading;

//for (int i = 0; i < 10; i++)
//{
//    Thread.Sleep(500);      // задержка выполнения на 500 миллисекунд
//    Console.WriteLine(i);
//}

/////////////////////////

//Мова C# дозволяє запускати та виконувати в рамках програми кілька потоків, які виконуватимуться одночасно.

//Для створення потоку застосовується один із конструкторів класу Thread :

//Thread(ThreadStart) : як параметр приймає об'єкт делегата ThreadStart,
//який представляє виконувану в потоці дію

//Thread(ThreadStart, Int32) : на додаток до делегата ThreadStart приймає числове значення,
//яке встановлює розмір стека, що виділяється під даний потік

//Thread(ParameterizedThreadStart) : як параметр приймає об'єкт делегата ParameterizedThreadStart,
//який представляє виконувану в потоці дію

//Thread(ParameterizedThreadStart, Int32) : разом із делегатом ParameterizedThreadStart
//приймає числове значення, яке встановлює розмір стека для цього потоку

//Незалежно від того, який конструктор буде застосовуватися для створення,
//нам треба визначити дію, що виконується в потоці. У статті розглянемо використання делегата ThreadStart.
//Цей делегат є дією, яка не приймає жодних параметрів і не повертає жодного значення:

// public delegate void ThreadStart();

// Тобто, під цей делегат нам треба визначити метод, який має тип void і не приймає жодних параметрів.
// Приклади визначення потоків:

//Thread myThread1 = new Thread(Print);
//Thread myThread2 = new Thread(new ThreadStart(Print));
//Thread myThread3 = new Thread(() => Console.WriteLine("Hello Threads"));

//void Print() => Console.WriteLine("Hello Threads");

// Для запуску нового потоку застосовується метод Start класу Thread:

//using System.Threading;

//// создаем новый поток
//Thread myThread1 = new Thread(Print);
//Thread myThread2 = new Thread(new ThreadStart(Print));
//Thread myThread3 = new Thread(() => Console.WriteLine("Hello Threads"));

//myThread1.Start();  // запускаем поток myThread1
//myThread2.Start();  // запускаем поток myThread2
//myThread3.Start();  // запускаем поток myThread3

//void Print() => Console.WriteLine("Hello Threads");

//
// Перевагою потоком і те, що можуть виконуватися одночасно. Наприклад:

//using System.Threading;
//using System.Text;

//Console.OutputEncoding = Encoding.UTF8;

//// создаем новый поток
//Thread myThread = new Thread(Print);
//// запускаем поток myThread
//myThread.Start();
//// myThread.Join();
//Console.WriteLine(myThread.ThreadState.ToString());

//// действия, выполняемые в главном потоке
//for (int i = 0; i < 5; i++)
//{
//    Console.WriteLine($"Главный поток: {i}");
//    Thread.Sleep(300);
//}

//// действия, выполняемые во втором потокке
//void Print()
//{
//    for (int i = 0; i < 10; i++)
//    {
//        Console.WriteLine($"Второй поток: {i}");
//        Thread.Sleep(400);
//    }
//}

//Тут новий потік вироблятиме дії, визначені у методі Print, тобто виводити числа від 0 до 4 на консоль.
//Причому після кожного висновку провадиться затримка на 400 мілісекунд.

//У головному потоці - у методі Main створюємо та запускаємо новий потік, у якому виконується метод Print:

//Thread myThread = new Thread(Print);
//myThread.Start();

//Крім того, в головному потоці робимо аналогічні дії -
//виводимо на консоль числа від 0 до 4 із затримкою в 300 мілісекунд.

//Таким чином, у нашій програмі працюватимуть одночасно головний потік, представлений методом Main,
//та другий потік, у якому виконується метод Print. Як тільки всі потоки відпрацюють, програма завершить виконання.

//Подібно ми можемо створити і запускати і три, і чотири, і цілий набір нових потоків,
//які зможуть вирішувати ті чи інші завдання.

////////////
//щоб передати якісь параметри в потік?

//Для цієї мети використовується делегат Parameterized ThreadStart , який передається в конструктор класу Thread:

// public delegate void ParameterizedThreadStart(object? obj);

//Застосування делегата ParameterizedThreadStart багато в чому схоже на роботу з ThreadStart.
//Розглянемо з прикладу:

//using System.Threading;

//// создаем новые потоки
//Thread myThread1 = new Thread(new ParameterizedThreadStart(Print));
//Thread myThread2 = new Thread(Print);
//Thread myThread3 = new Thread(message => Console.WriteLine(message));

//// запускаем потоки
//myThread1.Start("Hello");
//myThread2.Start("Hi");
//myThread3.Start("Salut");


//void Print(object? message) => Console.WriteLine(message);

//При створенні потоку в конструктор класу Thread передається об'єкт делегата
//ParameterizedThreadStart new Thread(new ParameterizedThreadStart(Print))або безпосередньо метод,
//який відповідає цьому делегату ( new Thread(Print)),
//у тому числі у вигляді лямбда-вираження ( new Thread(message => Console.WriteLine(message)))

//Потім при запуску потоку метод Start()передається значення, яке передається параметру методу Print.

// При використанні ParameterizedThreadStart ми стикаємося з обмеженням:
// ми можемо запускати у другому потоці тільки такий метод,
// який як єдиний параметр приймає об'єкт типу object?.
// Тому якщо хочемо використовувати дані інших типів, у методі необхідно виконати приведення типів.
// Наприклад:

//using System.Threading;

//int number = 4;
//// создаем новый поток
//Thread myThread = new Thread(Print);
//myThread.Start(number);    // n * n = 16


//// действия, выполняемые во втором потокке
//void Print(object? obj)
//{
//    // здесь мы ожидаем получить число
//    if (obj is int n)
//    {
//        Console.WriteLine($"n * n = {n * n}");
//    }
//}


//у разі нам треба додатково привести передане значення типу int, щоб його використовувати у обчисленнях.

//Але що робити, якщо треба передати не один, а кілька параметрів різного типу? І тут можна визначити свої типи:

//using System.Threading;

//Person tom = new Person("Tom", 37);
//// создаем новый поток
//Thread myThread = new Thread(Print);
//myThread.Start(tom);

//void Print(object? obj)
//{
//    // здесь мы ожидаем получить объект Person
//    if (obj is Person person)
//    {
//        Console.WriteLine($"Name = {person.Name}");
//        Console.WriteLine($"Age = {person.Age}");
//    }
//}

//record class Person(string Name, int Age);

//Спочатку визначаємо спеціальний клас Person, об'єкт якого передаватиметься на другий потік,
//а методі Main передаємо його у другий потік.

//Але тут знову ж таки є одне обмеження: метод Thread.Startне є типобезпечним,
//тобто ми можемо передати в нього будь-який тип,
//і потім нам доведеться наводити переданий об'єкт до потрібного нам типу.
//Для вирішення цієї проблеми рекомендується оголошувати всі використовувані
//методи та змінні у спеціальному класі, а в основній програмі запускати потік через ThreadStart.
//Наприклад:

//using System.Threading;

//Person tom = new Person("Tom", 37);
//// создаем новый поток
//Thread myThread = new Thread(tom.Print);
//myThread.Start();

//record class Person(string Name, int Age)
//{
//    public void Print()
//    {
//        Console.WriteLine($"Name = {Name}");
//        Console.WriteLine($"Age = {Age}");
//    }
//}

/////

// Синхронізація потоків

// Нерідко в потоках використовуються деякі ресурси, що розділяються, загальні для всієї програми.
// Це може бути загальні змінні, файли, інші ресурси. Наприклад:

int x = 0;

// запускаем пять потоков
for (int i = 1; i < 6; i++)
{
    Thread myThread = new(Print);
    myThread.Name = $"Thread {i}";   // устанавливаем имя для каждого потока
    myThread.Start();
}

void Print()
{
    x = 1;
    for (int i = 1; i < 6; i++)
    {
        Console.WriteLine($"{Thread.CurrentThread.Name}: {x}");
        x++;
        Thread.Sleep(100);
    }
}

// Тут у нас запускаються п'ять потоків, які викликають метод Print і які працюють із загальною змінною x.
// І ми припускаємо, що метод виведе всі значення від 1 до 5. І так для кожного потоку.
// Однак у реальності процесі роботи відбуватиметься перемикання між потоками,
// і значення змінної x стає непередбачуваним.

// Вирішення проблеми полягає в тому, щоб синхронізувати потоки і обмежити доступ до ресурсів,
// що розділяються, на час їх використання яким-небудь потоком. Для цього використовується ключове слово lock .
// Оператор lock визначає блок коду, у якому весь код блокується
// і стає недоступним інших потоків до завершення роботи поточного потоку.
// Інші потоки поміщаються в чергу очікування і чекають, поки поточний потік не звільнить цей блок коду.
// У результаті за допомогою lock ми можемо переробити попередній приклад так:

//int x = 0;
//object locker = new();  // объект-заглушка
//// запускаем пять потоков
//for (int i = 1; i < 6; i++)
//{
//    Thread myThread = new(Print);
//    myThread.Name = $"Thread {i}";
//    myThread.Start();
//}


//void Print()
//{
//    lock (locker)
//    {
//        x = 1;
//        for (int i = 1; i < 6; i++)
//        {
//            Console.WriteLine($"{Thread.CurrentThread.Name}: {x}");
//            x++;
//            Thread.Sleep(100);
//        }
//    }
//}

// Для блокування ключового слова lock використовується об'єкт-заглушка, в даному випадку це змінна locker.
// Зазвичай це змінна типу об'єкта. І коли виконання доходить до оператора lock, об'єкт locker блокується,
// і на час його блокування монопольний доступ до блоку коду має лише один потік.
// Після закінчення роботи блоку коду, об'єкт locker звільняється та стає доступним для інших потоків.

///////////////////////////////////
// Монітори

//Поряд із оператором lock для синхронізації потоків ми можемо використовувати монітори,
//представлені класом System.Threading.Monitor . Для керування синхронізацією цей клас надає такі методи:

//void Enter(object obj) : отримує в ексклюзивне володіння об'єкт, що передається як параметр.

//void Enter(object obj, bool acquiredLock) : додатково приймає другий параметр -
//логічне значення, яке вказує, чи отримано володіння над об'єктом з першого параметра

//void Exit(object obj) : звільняє раніше захоплений об'єкт

//bool IsEntered(object obj) : повертає true, якщо монітор захопив об'єкт obj

//void Pulse (object obj) : повідомляє потік із черги очікування, що поточний потік звільнив об'єкт obj

//PulseAll(object obj) : повідомляє всі потоки з черги очікування, що поточний потік звільнив об'єкт obj.
//Після чого один із потоків з черги очікування захоплює об'єкт obj.

//bool TryEnter (object obj) : намагається захопити об'єкт obj. Якщо володіння над об'єктом успішно одержано,
//то повертається значення true

//bool Wait (object obj) : звільняє блокування об'єкта та переводить потік у чергу очікування об'єкта.
//Наступний потік у черзі готовності об'єкта блокує цей об'єкт. А всі потоки, які викликали метод Wait, залишаються в черзі очікування, доки не отримають сигналу від методу Monitor.Pulse або Monitor.PulseAll, надісланого власником блокування.

//Власне конструкція оператора lock інкапсулює в собі синтаксис використання моніторів.
//Наприклад, у минулій темі для синхронізації потоків застосовувався оператор lock :

//int x = 0;
//object locker = new();  // объект-заглушка
//// запускаем пять потоков
//for (int i = 1; i < 6; i++)
//{
//    Thread myThread = new(Print);
//    myThread.Name = $"Thread {i}";
//    myThread.Start();
//}


//void Print()
//{
//    lock (locker)
//    {
//        x = 1;
//        for (int i = 1; i < 6; i++)
//        {
//            Console.WriteLine($"{Thread.CurrentThread.Name}: {x}");
//            x++;
//            Thread.Sleep(100);
//        }
//    }
//}

//
// Фактично цей приклад буде еквівалентний наступному коду:

//int x = 0;
//object locker = new();  // объект-заглушка
//// запускаем пять потоков
//for (int i = 1; i < 6; i++)
//{
//    Thread myThread = new(Print);
//    myThread.Name = $"Thread {i}";
//    myThread.Start();
//}

//void Print()
//{
//    bool acquiredLock = false;
//    try
//    {
//        Monitor.Enter(locker, ref acquiredLock);
//        x = 1;
//        for (int i = 1; i < 6; i++)
//        {
//            Console.WriteLine($"{Thread.CurrentThread.Name}: {x}");
//            x++;
//            Thread.Sleep(100);
//        }
//    }
//    finally
//    {
//        if (acquiredLock) Monitor.Exit(locker);
//    }
//}

// Метод Monitor.Enter приймає два параметри - об'єкт блокування та значення типу bool,
// яке вказує на результат блокування (якщо він дорівнює true, то блокування успішно виконано).
// Фактично, цей метод блокує об'єкт locker так само, як це робить оператор lock.
// А в блоці try...finally за допомогою методу Monitor.Exitвідбувається звільнення об'єкта locker,
// якщо блокування здійснено успішно, і він стає доступним для інших потоків.

/////
// Клас AutoResetEvent

//Клас AutoResetEvent також служить цілям синхронізації потоків.
//Цей клас представляє подію синхронізації потоків,
//який дозволяє при отриманні сигналу переключити даний об'єкт-подію сигнального в несигнальний стан.

//Для керування синхронізацією клас AutoResetEvent надає низку методів:

//Reset() : визначає несигнальний стан об'єкта, блокуючи потоки.

//Set(); : задає сигнальний стан об'єкта,
//дозволяючи одному або декільком потокам очікування продовжити роботу.

//WaitOne() : задає несигнальний стан та блокує поточний потік,
//доки поточний об'єкт AutoResetEvent не отримає сигнал.

//Подія синхронізації може перебувати у сигнальному та несигнальному стані.
//Якщо стан події несигнальний, потік, який викликає метод WaitOne,
//буде заблоковано, доки стан події стане сигнальним. Метод Set, навпаки, визначає сигнальний стан події.

//Так, в одній із попередніх тем для синхронізації потоків застосовувався оператор lock:

//int x = 0;
//object locker = new();  // объект-заглушка
//// запускаем пять потоков
//for (int i = 1; i < 6; i++)
//{
//    Thread myThread = new(Print);
//    myThread.Name = $"Thread {i}";
//    myThread.Start();
//}


//void Print()
//{
//    lock (locker)
//    {
//        x = 1;
//        for (int i = 1; i < 6; i++)
//        {
//            Console.WriteLine($"{Thread.CurrentThread.Name}: {x}");
//            x++;
//            Thread.Sleep(100);
//        }
//    }
//}

// Перепишемо цей приклад з використанням AutoResetEvent :

//int x = 0;  // общий ресурс

//AutoResetEvent waitHandler = new AutoResetEvent(true);  // объект-событие

//// запускаем пять потоков
//for (int i = 1; i < 6; i++)
//{
//    Thread myThread = new(Print);
//    myThread.Name = $"Thread {i}";
//    myThread.Start();
//}


//void Print()
//{
//    waitHandler.WaitOne();  // ожидаем сигнала
//    x = 1;
//    for (int i = 1; i < 6; i++)
//    {
//        Console.WriteLine($"{Thread.CurrentThread.Name}: {x}");
//        x++;
//        Thread.Sleep(100);
//    }
//    waitHandler.Set();  //  сигнализируем, что waitHandler в сигнальном состоянии
//}


//По - перше, створюємо змінну типу AutoResetEvent.
//Передаючи в конструктор значення true, тим самим вказуємо,
//що створюваний об'єкт спочатку буде у сигнальному стані.

//Коли починає працювати потік, то насамперед спрацьовує певний у методі Print виклик waitHandler.WaitOne().
//Метод WaitOne вказує, що поточний потік переводиться в стан очікування,
//доки об'єкт waitHandler не буде переведений у стан. І так усі потоки у нас перетворюються на стан очікування.

//Після завершення роботи викликається метод waitHandler.Set,
//який повідомляє всі очікувані потоки, що об'єкт waitHandler знову знаходиться в сигнальному стані,
//і один із потоків "захоплює" даний об'єкт, переводить у несигнальний стан і виконує свій код.
//А решту потоків знову чекають.

//Так як у конструкторі AutoResetEvent ми вказуємо, що об'єкт спочатку знаходиться в сигнальному стані,
//то перший із черги потоків захоплює даний об'єкт і починає виконувати свій код.

//Але якби ми написали AutoResetEvent waitHandler = new AutoResetEvent(false),
//тоді об'єкт спочатку був би в несигнальному стані,
//а оскільки всі потоки блокуються методом waitHandler.WaitOne()до очікування сигналу,
//то в нас просто стало б блокування програми, і програма не виконувала б ніяких дій.

//Якщо у нас у програмі використовуються кілька об'єктів AutoResetEvent,
//то ми можемо використовувати для відстеження стану цих об'єктів статичні методи WaitAll і WaitAny ,
//які в якості параметра приймають масив об'єктів класу WaitHandle - базового класу для AutoResetEvent.

//Так, ми також можемо використовувати WaitAll у наведеному вище прикладі. Для цього треба рядок

//waitHandler.WaitOne();

//замінити на таку:

//AutoResetEvent.WaitAll(new WaitHandle[] { waitHandler });

///////////////////////////////////////////////////
// М'ютекси

//Ще один інструмент керування синхронізацією потоків представляє клас Mutex або м'ютекс,
//який також розміщується у просторі імен System.Threading.

//Так, візьмемо приклад з оператором lock з однією з попередніх тем,
//у якому застосовувалася синхронізація потоків:


//int x = 0;
//object locker = new();  // объект-заглушка
//// запускаем пять потоков
//for (int i = 1; i < 6; i++)
//{
//    Thread myThread = new(Print);
//    myThread.Name = $"Thread {i}";
//    myThread.Start();
//}


//void Print()
//{
//    lock (locker)
//    {
//        x = 1;
//        for (int i = 1; i < 6; i++)
//        {
//            Console.WriteLine($"{Thread.CurrentThread.Name}: {x}");
//            x++;
//            Thread.Sleep(100);
//        }
//    }
//}

//// І перепишемо цей приклад, використовуючи м'ютекси:

//int x = 0;
//Mutex mutexObj = new();

//// запускаем пять потоков
//for (int i = 1; i < 6; i++)
//{
//    Thread myThread = new(Print);
//    myThread.Name = $"Thread {i}";
//    myThread.Start();
//}

//void Print()
//{
//    mutexObj.WaitOne();     // приостанавливаем поток до получения мьютекса
//    x = 1;
//    for (int i = 1; i < 6; i++)
//    {
//        Console.WriteLine($"{Thread.CurrentThread.Name}: {x}");
//        x++;
//        Thread.Sleep(100);
//    }
//    mutexObj.ReleaseMutex();    // освобождаем мьютекс
//}

//
// Спочатку створюємо об'єкт м'ютексу:

// 	
// Mutex mutexObj = new Mutex()

//Основну роботу із синхронізації виконують методи WaitOne() та ReleaseMutex() .
//Метод mutexObj.WaitOne()припиняє виконання потоку до тих пір, поки не буде отримано mutex mutexObj.

//Спочатку м'ютекс вільний, тому його отримує один із потоків.

//Після виконання всіх дій, коли м'ютекс не потрібен,
//потік звільняє його з допомогою методу mutexObj.ReleaseMutex(). А м'ютекс отримує один із очікуваних потоків.

//Таким чином, коли виконання дійде до виклику mutexObj.WaitOne(),
//потік чекатиме, доки не звільниться м'ютекс. І після його здобуття продовжить виконувати свою роботу.

//////////////////////////
// Семафори

//Семафори є ще одним інструментом, який пропонує нам .NET платформа для управління синхронізацією.
//Семафори дозволяють обмежити кількість потоків, які мають доступ до певних ресурсів.
//У .NET семафори представлені класом Semaphore .

//Для створення семафору застосовується один із конструкторів класу Semaphore:

//Semaphore(int initialCount, int maximumCount) : параметр initialCountзадає початкову кількість потоків,
//а maximumCount- максимальну кількість потоків, які мають доступ до загальних ресурсів

//Semaphore (int initialCount, int maximumCount, string? name) : на додаток задає ім'я семафора

//Semaphore (int initialCount, int maximumCount, string? name, out bool createdNew) :
//останній параметр - createdNewпри значенні true вказує, що новий семафор був успішно створений.
//Якщо цей параметр дорівнює false, то семафор із зазначеним ім'ям вже існує

//Для роботи з потоками клас Semaphore має два основні методи:

//WaitOne() : очікує отримання вільного місця у семафорі

//Release() : звільняє місце у семафорі

//Наприклад, у нас таке завдання: є кілька читачів, які приходять до бібліотеки тричі на день і щось там читають.
//І нехай у нас буде обмеження, що одноразово в бібліотеці не може бути більше трьох читачів.
//Це завдання дуже легко вирішити за допомогою семафорів:

//using System.Text;

//Console.OutputEncoding = Encoding.UTF8;

//// запускаем пять потоков
//for (int i = 1; i < 6; i++)
//{
//    Reader reader = new Reader(i);
//}
//class Reader
//{
//    // создаем семафор
//    static Semaphore sem = new Semaphore(3, 3);
//    Thread myThread;
//    int count = 3;// счетчик чтения

//    public Reader(int i)
//    {
//        myThread = new Thread(Read);
//        myThread.Name = $"Читатель {i}";
//        myThread.Start();
//    }

//    public void Read()
//    {
//        while (count > 0)
//        {
//            sem.WaitOne();  // ожидаем, когда освободиться место

//            Console.WriteLine($"{Thread.CurrentThread.Name} входит в библиотеку");

//            Console.WriteLine($"{Thread.CurrentThread.Name} читает");
//            Thread.Sleep(1000);

//            Console.WriteLine($"{Thread.CurrentThread.Name} покидает библиотеку");

//            sem.Release();  // освобождаем место

//            count--;
//            Thread.Sleep(1000);
//        }
//    }
//}

//У програмі читач представлений класом Reader. Він інкапсулює всю функціональність,
//пов'язану з потоками через змінну Thread myThread.

//Сам семафор визначається у вигляді статичної змінної sem:

//статичний семафор sem = новий семафор(3, 3);.
//Його конструктор приймає два параметри: перший вказує, якій кількості об'єктів спочатку буде доступний семафор,
//а другий параметр вказує, яка максимальна кількість об'єктів буде використовувати цей семафор.
//В даному випадку у нас тільки три читачі можуть одночасно перебувати в бібліотеці, тому максимальна кількість дорівнює 3.

//Основний функціонал зосереджений у методі Read, який виконується в потоці.
//На початку для очікування отримання семафору використовується метод sem.WaitOne():

//sem.WaitOne();  // ожидаем, когда освободиться место

//Після того, як у семафорі звільниться місце, цей потік заповнює вільне місце та починає виконувати всі подальші дії.

//Після закінчення читання ми вивільняємо семафор за допомогою методу sem.Release():

//sem.Release();  // освобождаем место

//Після цього у семафорі звільняється одне місце, яке заповнює інший потік.

///////////////////////////////////////////////////////////
//Паралельне програмування та бібліотека TPL
//Завдання та клас Task


//В епоху багатоядерних машин, які дозволяють паралельно виконувати відразу кілька процесів,
//стандартних засобів роботи з потоками в .NET вже виявилося замало.
//Тому у фреймворк .NET була додана бібліотека паралельних завдань TPL (Task Parallel Library),
//основний функціонал якої знаходиться у просторі імен System.Threading.Tasks .
//Ця бібліотека полегшує роботу з багатопроцесорними, багатоядерними системами.
//Крім того, вона полегшує роботу зі створення нових потоків.
//Тому зазвичай рекомендується використовувати саме TPL та її класи для створення багатопотокових додатків,
//хоча стандартні засоби та клас Thread, як і раніше, знаходять широке застосування.

//У основі бібліотеки TPL лежить концепція завдань, кожна з яких описує окрему тривалу операцію.
//У бібліотеці класів .NET завдання представлено спеціальним класом-класом Task ,
//який знаходиться у просторі імен System.Threading.Tasks .
//Даний клас описує окреме завдання, яке запускається асинхронно в одному з потоків з пулу потоків.
//Хоча її також можна запускати синхронно у поточному потоці.

//Для визначення та запуску задачі можна використовувати різні способи.

//Перший спосіб створення об'єкта Task та виклик у нього методу Start:

//Task task = new Task(() => Console.WriteLine("Hello Task!"));
//task.Start();

//Як параметр об'єкт Task приймає делегат Action, тобто ми можемо передати будь-яку дію, 
//    яка відповідає даному делегату, наприклад, лямбда-вираз, як у даному випадку, або посилання на будь-який метод. 
//    Тобто в даному випадку при виконанні завдання на консоль буде виводитись рядок "Hello Task!".

//А метод, Start()власне, запускає завдання.


//Другий спосіб полягає у використанні статичного методу Task.Factory.StartNew() . 
//Цей метод також як параметр приймає делегат Action, який вказує, яка дія виконуватиметься. 
//При цьому цей метод одразу ж запускає завдання:

//Task task = Task.Factory.StartNew(() => Console.WriteLine("Hello Task!"));

//Як результат метод повертає запущене завдання.

//Третій спосіб визначення та запуску задач представляє використання статичного методу Task.Run() :

//Task task = Task.Run(() => Console.WriteLine("Hello Task!"));

//Метод Task.Run()також як параметр може приймати делегат Action - дія, що виконується, і повертає об'єкт Task.

//Визначимо невелику програму, де використовуємо всі ці способи:

//Task task1 = new Task(() => Console.WriteLine("Task1 is executed"));
//task1.Start();

//Task task2 = Task.Factory.StartNew(() => Console.WriteLine("Task2 is executed"));

//Task task3 = Task.Run(() => Console.WriteLine("Task3 is executed"));

//Отже, в даному коді завдання створюються та запускаються,
//але при виконанні програми на консолі ми можемо нічого не побачити.
//Чому? Тому що коли потік завдання запускається з основного потоку програми - потоку методу Main,
//програма може завершити виконання до того, як всі три або навіть хоча б одне з трьох завдань почне виконання.
//Щоб цього не сталося, ми можемо програмним чином очікувати на завершення завдання.

// Очікування завершення завдання

// Щоб додаток очікував завершення завдання, можна використовувати метод Wait() об'єкта Task:

//Task task1 = new Task(() => Console.WriteLine("Task1 is executed"));
//task1.Start();

//Task task2 = Task.Factory.StartNew(() => Console.WriteLine("Task2 is executed"));

//Task task3 = Task.Run(() => Console.WriteLine("Task3 is executed"));

//task1.Wait();   // ожидаем завершения задачи task1
//task2.Wait();   // ожидаем завершения задачи task2
//task3.Wait();   // ожидаем завершения задачи task3

//
//Консольний висновок не детерміновано, оскільки завдання не виконуються послідовно.
//Перше запущене завдання може завершити виконання після останнього завдання.

//Варто зазначити, що метод Wait() блокує викликаючий потік, в якому запущено завдання,
//поки це завдання не завершить виконання. Наприклад:

//Console.WriteLine("Main Starts");
//// создаем задачу
//Task task1 = new Task(() =>
//{
//    Console.WriteLine("Task Starts");
//    Thread.Sleep(1000);     // задержка на 1 секунду - имитация долгой работы
//    Console.WriteLine("Task Ends");
//});
//task1.Start();  // запускаем задачу
//task1.Wait();   // ожидаем выполнения задачи
//Console.WriteLine("Main Ends");

//Для емуляції довготривалої роботи тут завдання task1 встановлюється затримка на 1 секунду.
//У результаті, коли виконання дійде до виклику task1.Wait() основний потік зупинить виконання і чекатиме завершення завдання.
//

// Якщо така поведінка не є принциповою, то очікування завершення завдання можна помістити в кінець методу Main:

//Console.WriteLine("Main Starts");
//// создаем задачу
//Task task1 = new Task(() =>
//{
//    Console.WriteLine("Task Starts");
//    Thread.Sleep(1000);     // задержка на 1 секунду - имитация долгой работы
//    Console.WriteLine("Task Ends");
//});
//task1.Start();  // запускаем задачу
//Console.WriteLine("Main Ends");
//task1.Wait();   // ожидаем выполнения задачи

// У цьому випадку програма все одно чекатиме завершення завдання,
// однак інші синхронні дії в основному потоці не будуть блокуватися і чекати завершення завдання.

// Синхронний запуск завдання

// За замовчуванням завдання запускаються асинхронно. Однак за допомогою методу RunSynchronously() можна запускати синхронно:

//Console.WriteLine("Main Starts");
//// создаем задачу
//Task task1 = new Task(() =>
//{
//    Console.WriteLine("Task Starts");
//    Thread.Sleep(1000);
//    Console.WriteLine("Task Ends");
//});
//task1.RunSynchronously(); // запускаем задачу синхронно
//Console.WriteLine("Main Ends"); // этот вызов ждет завершения задачи task1 

//
//Властивості класу Task
//Клас Task має низку властивостей, за допомогою яких ми можемо отримати інформацію про об'єкт. Деякі з них:

//AsyncState : повертає об'єкт стану задачі

//CurrentId : повертає ідентифікатор поточного завдання (статична властивість)

//Id: повертає ідентифікатор поточного завдання

//Exception : повертає об'єкт виключення, що виник під час виконання завдання

//Status : повертає статус завдання. Представляє перелік System.Threading.Tasks.TaskStatus, який має такі значення:

//Canceled: завдання скасовано

//Created: завдання створено, але ще не запущено

//Faulted: у процесі роботи завдання стався виняток

//RanToCompletion: завдання успішно завершено

//Running: завдання запущено, але ще не завершено

//WaitingForActivation: завдання очікує активації та постановки у графік виконання

//WaitingForChildrenToComplete: завдання завершено і тепер чекає завершення прикріплених до неї дочірніх завдань

//WaitingToRun: задача поставлена ​​в графік виконання, але ще не розпочала своє виконання

//IsCompleted : повертає true, якщо завдання завершено

//IsCanceled : повертає true, якщо завдання було скасовано

//IsFaulted : повертає true, якщо завдання завершилося у разі виключення

//IsCompletedSuccessfully : повертає true, якщо завдання завершилося успішно

//Task task1 = new Task(() =>
//{
//    Console.WriteLine($"Task{Task.CurrentId} Starts");
//    Thread.Sleep(1000);
//    Console.WriteLine($"Task{Task.CurrentId} Ends");
//});
//task1.Start(); //запускаем задачу

//// получаем информацию о задаче
//Console.WriteLine($"task1 Id: {task1.Id}");
//Console.WriteLine($"task1 is Completed: {task1.IsCompleted}");
//Console.WriteLine($"task1 Status: {task1.Status}");

//task1.Wait(); // ожидаем завершения задачи

//////////////////////////////////////////////////////
// Робота з класом Task

// Вкладені завдання
// Одна задача може запускати іншу – вкладену задачу. У цьому ці завдання виконуються незалежно друг від друга.
// Наприклад:

//var outer = Task.Factory.StartNew(() =>      // внешняя задача
//{
//    Console.WriteLine("Outer task starting...");
//    var inner = Task.Factory.StartNew(() =>  // вложенная задача
//    {
//        Console.WriteLine("Inner task starting...");
//        Thread.Sleep(2000);
//        Console.WriteLine("Inner task finished.");
//    });
//});
//outer.Wait(); // ожидаем выполнения внешней задачи
//Console.WriteLine("End of Main");

// Незважаючи на те, що тут ми очікуємо на виконання зовнішнього завдання,
// але вкладене завдання може завершити виконання навіть після завершення методу Main

//При цьому внутрішнє завдання може навіть не розпочати виконання до завершення роботи основного потоку програми.
//Тобто в даному випадку зовнішнє та вкладене завдання виконуються незалежно один від одного.

//Якщо необхідно, щоб вкладена задача виконувалася як частина зовнішньої,
//необхідно використовувати значення TaskCreationOptions.AttachedToParent :

//var outer = Task.Factory.StartNew(() =>      // внешняя задача
//{
//    Console.WriteLine("Outer task starting...");
//    var inner = Task.Factory.StartNew(() =>  // вложенная задача
//    {
//        Console.WriteLine("Inner task starting...");
//        Thread.Sleep(2000);
//        Console.WriteLine("Inner task finished.");
//    }, TaskCreationOptions.AttachedToParent);
//});
//outer.Wait(); // ожидаем выполнения внешней задачи
//Console.WriteLine("End of Main");

// В даному випадку вкладена задача прикріплена до зовнішньої та виконується як частина зовнішньої задачі.
// І зовнішнє завдання завершиться лише тоді, коли завершаться всі прикріплені до неї вкладені завдання.

// Масив завдань

// Так само як і з потоками, ми можемо створити та запустити масив завдань.
// Можна визначити всі завдання у масиві безпосередньо через об'єкт Task:

//Task[] tasks1 = new Task[3]
//{
//    new Task(() => Console.WriteLine("First Task")),
//    new Task(() => Console.WriteLine("Second Task")),
//    new Task(() => Console.WriteLine("Third Task"))
//};
//// запуск задач в массиве
//foreach (var t in tasks1)
//    t.Start();


//// Або також можна використовувати методи Task.Factory.StartNew або Task.Run і відразу запускати всі завдання:

//Task[] tasks2 = new Task[3];
//int j = 1;
//for (int i = 0; i < tasks2.Length; i++)
//    tasks2[i] = Task.Factory.StartNew(() => Console.WriteLine($"Task {j++}"));

//// Але в будь-якому випадку ми знову ж таки можемо зіткнутися з тим,
//// що всі завдання з масиву можуть завершитися після того, як відпрацює метод Main, в якому ці завдання запускаються:

//Task[] tasks = new Task[3];
//for (var i = 0; i < tasks.Length; i++)
//{
//    tasks[i] = new Task(() =>
//    {
//        Thread.Sleep(1000); // эмуляция долгой работы
//        Console.WriteLine($"Task{i} finished");
//    });
//    tasks[i].Start();   // запускаем задачу
//}
//Console.WriteLine("End Main");

//// Якщо необхідно завершити виконання програми або взагалі виконувати певний код лише після того,
//// як усі завдання з масиву завершаться, то застосовується метод Task.WaitAll(tasks) :


//Task[] tasks = new Task[3];
//for (var i = 0; i < tasks.Length; i++)
//{
//    tasks[i] = new Task(() =>
//    {
//        Thread.Sleep(1000); // эмуляция долгой работы
//        Console.WriteLine($"Task{i} finished");
//    });
//    tasks[i].Start();   // запускаем задачу
//}
//Console.WriteLine("End Main");

//Task.WaitAll(tasks); // ожидаем завершения всех задач

//// У цьому випадку спочатку завершаться всі завдання, і тільки потім буде виконуватися наступний код з методу Main:

//У той самий час порядок виконання самих завдань у масиві також недетерміновано.

//Також ми можемо використовувати метод Task.WaitAny(tasks) . Він чекає, поки завершиться бодай одне з масиву завдань.

////////
// Повернення результатів із завдань

// Завдання можуть виконуватися не тільки як процедури, а й повертати певні результати:

//int n1 = 4, n2 = 5;
//Task<int> sumTask = new Task<int>(() => Sum(n1, n2));
//sumTask.Start();

//int result = sumTask.Result;
//Console.WriteLine($"{n1} + {n2} = {result}"); // 4 + 5 = 9

//int Sum(int a, int b) => a + b;

//По - перше, щоб отримувати із завдання не якийсь результат, необхідно типізувати об'єкт Task тим типом,
//об'єкт якого ми хочемо отримати із завдання. Наприклад, у прикладі вище ми очікуємо із завдання sumTask
//отримати число типу int, відповідно типизуємо об'єкт Task даним типом - Task<int>.

//І, по-друге, як завдання має виконуватися метод, який повертає цей тип об'єкта.
//Так, у даному випадку у нас як завдання виконується метод Sum, який приймає два числа і на виході повертає
//їх суму - значення типу int.

//Повертається число зберігатиметься як Result: sumTask.Result.Нам не треба його приводити до типу int,
//воно вже саме по собі представлятиме число.

// int result = sumTask.Result;

//При цьому при зверненні до властивості Result поточний потік зупиняє виконання і чекає, 
//    коли буде отримано результат виконуваного завдання.

//Інший приклад:

//Task<Person> defaultPersonTask = new Task<Person>(() => new Person("Tom", 37));
//defaultPersonTask.Start();

//Person defaultPerson = defaultPersonTask.Result;
//Console.WriteLine($"{defaultPerson.Name} - {defaultPerson.Age}"); // Tom - 37

//record class Person(string Name, int Age);

// В даному випадку завдання defaultPersonTask повертає об'єкт типу Person, який ми можемо отримати із властивості Result.

/////////////////////////////////////
// Завдання продовження

//Завдання продовження або continution task дозволяють визначити завдання, які виконуються після завершення інших завдань. Завдяки цьому ми можемо викликати після виконання одного завдання кілька інших, визначити умови їхнього виклику, передати з попереднього завдання до наступного деякі дані.

//Завдання продовження схожі на методи зворотного виклику, але є звичайними завданнями Task. Подивимося на прикладі:

//Task task1 = new Task(() =>
//{
//    Console.WriteLine($"Id задачи: {Task.CurrentId}");
//});

//// задача продолжения - task2 выполняется после task1
//Task task2 = task1.ContinueWith(PrintTask);

//task1.Start();

//// ждем окончания второй задачи
//task2.Wait();
//Console.WriteLine("Конец метода Main");


//void PrintTask(Task t)
//{
//    Console.WriteLine($"Id задачи: {Task.CurrentId}");
//    Console.WriteLine($"Id предыдущей задачи: {t.Id}");
//    Thread.Sleep(3000);
//}

//Перше завдання задається за допомогою лямбда-вираження, яке просто виводить id цього завдання.
//Друге завдання-завдання продовження задається за допомогою методу ContinueWith ,
//який як параметр приймає делегат Action<Task>.
//Тобто метод PrintTask, який передається на виклик ContinueWith, повинен приймати параметр типу Task.

//Завдяки передачі в метод параметра Task, ми можемо отримати різні властивості попередньої задачі,
//наприклад, в даному випадку отримує її Id.

//І після завершення завдання task1 відразу буде викликатись завдання task2.

// Також ми можемо передавати конкретний результат роботи попереднього завдання:

//Task<int> sumTask = new Task<int>(() => Sum(4, 5));

//// задача продолжения
//Task printTask = sumTask.ContinueWith(task => PrintResult(task.Result));

//sumTask.Start();

//// ждем окончания второй задачи
//printTask.Wait();
//Console.WriteLine("Конец метода Main");

//int Sum(int a, int b) => a + b;
//void PrintResult(int sum) => Console.WriteLine($"Sum: {sum}");

// В даному випадку задача sumTask виконує метод Sum та повертає його результат.
// Завдання printTask є завданням продовження, виконується відразу після sumTask та отримує її результат.
//
// Так, у виклику

// Task printTask = sumTask.ContinueWith(task => PrintResult(task.Result));

//Параметр task в лямбда-вираженні фактично представляє завдання sumTask, з якої витягується результат.

//Подібним чином можна побудувати цілий ланцюжок завдань, що послідовно виконуються:

//Task task1 = new Task(() => Console.WriteLine($"Current Task: {Task.CurrentId}"));

//// задача продолжения
//Task task2 = task1.ContinueWith(t =>
//    Console.WriteLine($"Current Task: {Task.CurrentId}  Previous Task: {t.Id}"));

//Task task3 = task2.ContinueWith(t =>
//    Console.WriteLine($"Current Task: {Task.CurrentId}  Previous Task: {t.Id}"));


//Task task4 = task3.ContinueWith(t =>
//    Console.WriteLine($"Current Task: {Task.CurrentId}  Previous Task: {t.Id}"));

//task1.Start();

//task4.Wait();   //  ждем завершения последней задачи
//Console.WriteLine("Конец метода Main");

///////////////////////////////
// Клас Parallel

//Клас Parallel також є частиною TPL та призначений для спрощення паралельного виконання коду.
//    Parallel має низку методів, які дозволяють розпаралелити завдання.

//Одним з методів, що дозволяють паралельне виконання завдань, є метод Invoke:

// метод Parallel.Invoke выполняет три метода
//Parallel.Invoke(
//    Print,
//    () =>
//    {
//        Console.WriteLine($"Выполняется задача {Task.CurrentId}");
//        Thread.Sleep(3000);
//    },
//    () => Square(5)
//);

//void Print()
//{
//    Console.WriteLine($"Выполняется задача {Task.CurrentId}");
//    Thread.Sleep(3000);
//}
//// вычисляем квадрат числа
//void Square(int n)
//{
//    Console.WriteLine($"Выполняется задача {Task.CurrentId}");
//    Thread.Sleep(3000);
//    Console.WriteLine($"Результат {n * n}");
//}

//Метод Parallel.Invokeяк параметр приймає масив об'єктів Action,
//тобто ми можемо передати в даний метод набір методів, які будуть викликатись при його виконанні.
//Кількість методів може бути різною, але в даному випадку ми визначаємо виконання трьох методів.
//Знову ж таки як і у випадку з класом Task ми можемо передати або назву методу, або лямбда-вираз.

//І таким чином, за наявності кількох ядер на цільовій машині ці методи будуть виконуватися паралельно на різних ядрах. 

// Метод Parallel.For дозволяє виконувати ітерацію циклу паралельно. Він має таке визначення:

// For(int, int, Action<int>)

// Перший параметр методу визначає початковий індекс елемента в циклі, а другий параметр - кінцевий індекс.
// Третій параметр – делегат Action – вказує на метод, який виконуватиметься один раз за ітерацію:

//Parallel.For(1, 5, Square);

//// вычисляем квадрат числа
//void Square(int n)
//{
//    Console.WriteLine($"Выполняется задача {Task.CurrentId}");
//    Console.WriteLine($"Квадрат числа {n} равен {n * n}");
//    Thread.Sleep(2000);
//}

//В даному випадку в якості першого параметра метод Parallel.For передається число 1, а в якості другого - число 5.
//Таким чином, метод вести ітерацію з 1 до 4 включно. Третій параметр є метод, який обчислює квадрат числа.
//Оскільки цей параметр представляє тип Action<int>, цей метод як параметр повинен приймати об'єкт int.

//А як значення параметра цей метод передається лічильник, який проходить у циклі від 1 до 4 включно.
//І метод Square таким чином викликається 4 рази.

//Метод Parallel.ForEach здійснює ітерацію по колекції, що реалізує інтерфейс IEnumerable ,
//    подібно до циклу foreach, тільки здійснює паралельне виконання перебору. Він має таке визначення:

//ParallelLoopResult ForEach<TSource>(IEnumerable<TSource> source, Action<TSource> body)

//де перший параметр представляє колекцію, що перебирається, а другий параметр - делегат, 
//    що виконується один раз за ітерацію для кожного елемента колекції, що перебирається.

//На виході метод повертає структуру ParallelLoopResult, що містить інформацію про виконання циклу.

//ParallelLoopResult result = Parallel.ForEach<int>(
//       new List<int>() { 1, 3, 5, 8 },
//       Square
//);

//// вычисляем квадрат числа
//void Square(int n)
//{
//    Console.WriteLine($"Выполняется задача {Task.CurrentId}");
//    Console.WriteLine($"Квадрат числа {n} равен {n * n}");
//    Thread.Sleep(2000);
//}

//В даному випадку оскільки ми використовуємо колекцію об'єктів int, то і метод, який ми передаємо як другий параметр,
//повинен як параметр приймати значення int. 

// Вихід із циклу

//У стандартних циклах for і foreach передбачений передчасний вихід із циклу за допомогою оператора break.
//    У методах Parallel.ForEach та Parallel.For ми також можемо, не чекаючи закінчення циклу, вийти з нього:

//ParallelLoopResult result = Parallel.For(1, 10, Square);
//if (!result.IsCompleted)
//    Console.WriteLine($"Выполнение цикла завершено на итерации {result.LowestBreakIteration}");

//// вычисляем квадрат числа
//void Square(int n, ParallelLoopState pls)
//{
//    if (n == 5) pls.Break();    // если передано 5, выходим из цикла

//    Console.WriteLine($"Квадрат числа {n} равен {n * n}");
//    Thread.Sleep(2000);
//}

//Тут метод Square, який обробляє кожну ітерацію, приймає додатковий параметр – об'єкт ParallelLoopState .
//І якщо лічильник у циклі досягне значення 5, викликається метод Break.
//Завдяки чому система здійснить вихід і припинить виконання методу Parallel.For за першої зручної нагоди.

//Методи Parallel.ForEach і Parallel.For повертають об'єкт ParallelLoopResult ,
//найбільш значущими властивостями якого є наступні два:

//IsCompleted : визначає, чи завершилося повне виконання паралельного циклу

//LowestBreakIteration : повертає індекс, на якому відбулося переривання роботи циклу

//Так як у нас на індексі рівному 5 відбувається переривання, то властивість IsCompleted буде мати значення false,
//а LowestBreakIteration
//дорівнюватиме 5.

