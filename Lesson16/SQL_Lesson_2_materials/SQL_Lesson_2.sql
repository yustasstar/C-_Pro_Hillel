--########################################################################################################
---- Основи проектування баз даних:
--Якість проектування бази даних дуже важлива. З добре спроектованою базою даних легше працювати, легше писати запити. 
--Для якісного проектування бази даних існують різні методики, різні послідовності кроків чи етапів, які багато в чому схожі. 
--І загалом ми можемо виділити такі етапи:
--Виділення сутностей та його атрибутів, які зберігатимуться у базі даних, і формування з них таблиць. 
--Атомізація складних атрибутів більш прості.
--Визначення унікальних ідентифікаторів (первинних ключів) об'єктів, що зберігаються у рядках таблиці
--Визначення відносин між таблицями за допомогою зовнішніх ключів
--########################################################################################################
--Нормалізація бази даних:
--У першому етапі відбувається виділення сутностей. Сутність (entity) є типом об'єктів, які повинні зберігатися в базі даних. 
--Кожна таблиця у базі даних має представляти одну сутність. Як правило, сутності відповідають об'єктам із реального світу.
--Кожна сутність визначає набір атрибутів. Атрибут є властивістю, яка описує деяку характеристику об'єкта.
--Кожен стовпець повинен зберігати один атрибут сутності. А кожен рядок представляє окремий об'єкт чи екземпляр сутності.

--Висхідний та низхідний підходи:
--При проектуванні бази даних на етапі виділення сутностей та їх атрибутів ми можемо використовувати два підходи: висхідний та низхідний.

--Висхідний підхід передбачає виділення необхідних атрибутів, які треба зберегти у бд. 
--Потім виділені атрибути групуються по суті, котрим згодом створюється таблиці. 
--Такий підхід найбільше підходить для проектування невеликих баз даних з невеликою кількістю атрибутів.

--Атомізація атрибутів
--При визначенні атрибутів відбувається поділ складних комплексних елементів більш прості. 
--Так, у випадку з ім'ям студента ми можемо його розбити на власне ім'я та прізвище. 
--Це дозволить згодом виконувати операції з цими поделементами окремо, наприклад, сортувати студентів лише на прізвище.

--Те саме стосується адреси - ми можемо зберегти всю адресу цілком, а можемо розбити її на частини - будинок, вулицю, місто тощо.

--У той самий час можливість поділу одного елемента на поделементи який завжди може бути затребуваною. 
--У низці завдань це може бути просто не потрібно. Виділяти необхідно лише ті елементи, які справді потрібні.

--Відповідно до цього аспекту ми можемо виділити у сутності "Студент" наступні атрибути: 
--ім'я студента, прізвище студента, рік народження, місто, вулиця, будинок, телефон.

--Домен
--Кожен атрибут має домен . Домен представляє набір допустимих значень одного чи кількох атрибутів. 
--По суті, домен визначає зміст і джерело значень, які можуть мати атрибути.

--Домени можуть відрізнятися для різних атрибутів, але кілька атрибутів можуть мати один домен.

--Наприклад, вище було визначено атрибути сутності студента. Визначимо використовувані домени:

--Ім'я . Домен представляє всі можливі імена, які можна використовувати. 
--Кожне ім'я становить рядок довжиною максимум 20 символів (малоймовірно, що нам можуть зустрітися імена понад 20 символів).

--Прізвище . Домен представляє всі можливі прізвища, які можна використовувати. Кожне прізвище представляє рядок довжиною максимум 20 символів.

--Рік народження . Домен представляє всі роки народження. Щороку є числовим значенням від 1950 до 2017 року.

--Місто . Домен представляє усі міста поточної країни. Кожне місто представляє рядок завдовжки максимум 50 символів.

--Вулиця . Домен представляє всі вулиці поточної країни. Кожна вулиця становить рядок довжиною максимум 50 символів.

--Будинок . Домен представляє всі можливі номери будинків. Кожен номер будинку є числом від 1 до, скажімо, 10 000.

--Телефон . Домен представляє всі телефонні номери. Кожен номер є рядком довжиною 11 символів.

--Визначаючи домен, ми відразу бачимо, які дані та яких типів зберігатимуть атрибути. 
--Якесь інше значення, яке відповідає домену, атрибут мати не може.

--У прикладі вище, кожен атрибут має свій домен. Але домени можуть збігатися. 
--Наприклад, якби сутність містила б такі два атрибути: місто народження та місто проживання, 
--то домен би збігався і був би одним і тим самим для обох атрибутів.

--Визначник NULL
--При визначенні атрибутів та їх домену необхідно проаналізувати, а чи може у атрибута відсутня значення. 
--Визначник NULL дозволяє встановити відсутність значення. 
--Наприклад, у прикладі вище у студента обов'язково має бути якесь ім'я, тому неприпустима ситуація, коли атрибут, 
--який представляє ім'я, не має значення.

--У той же час студент може не мати номер телефону або в рамках системи телефон не обов'язковий. 
--Тому на етапі проектування таблиці можна вказати, що цей атрибут дозволяє значення NULL.

--Як правило, більшість сучасних реляційних СУБД підтримують визначник NULL і дозволяють встановити його допустимість для стовпця таблиці.

-------------
-- Ключі

--Ключі є способом ідентифікації рядків у таблиці. За допомогою ключів ми також можемо зв'язувати рядки між різними таблицями у відносинах.

--Суперключ
--Superkey (суперключ) - комбінація атрибутів (стовпців), які унікально ідентифікують кожен рядок таблиці. 
--Це можуть бути і всі стовпці, і кілька, і один. При цьому рядки, які містять значення цих атрибутів, не повинні повторюватися.

--Наприклад, у нас є сутність Student, яка подає дані про користувачів і яка має такі атрибути:

--FirstName (ім'я)

--Прізвище

--Year (рік народження)

--Phone (номер телефона)

--Які атрибути в даному випадку можуть складати суперключ:

--{Ім'я, Прізвище, Рік, Телефон}

--{Ім'я, рік, телефон}

--{Прізвище, рік, телефон}

--{Ім'я, телефон}

--{Прізвище, Телефон}

--{Рік, телефон}

--{телефон}

--Кожен студент унікально може ідентифікувати телефонний номер, тому будь-які набори, в яких зустрічається атрибут Phone, представляють суперключ.

--А ось, наприклад, набір {FirstName, LastName, Year} не є суперключом, тому що у нас 
--теоретично можуть бути як мінімум два студенти з однаковим ім'ям, прізвищем та роком народження.

--Потенційний ключ
--Candidate key (потенційний ключ) - є мінімальним суперключом відношення (таблиці), тобто набір атрибутів, який задовольняє ряду умов:

--Непривідність : він не може бути скорочений, він містить мінімально можливий набір атрибутів

--Унікальність : він повинен мати унікальні значення незалежно від зміни рядка

--Наявність значення : він повинен мати значення NULL, тобто він обов'язково повинен мати значення.

--Візьмемо раніше виділені суперключі та знайдемо серед них candidate key. 
--Перший п'ять суперключів не відповідають першій умові, тому що всі їх можна скоротити до суперключа.

--{Ім'я, Прізвище, Рік, Телефон}

--{Ім'я, рік, телефон}

--{Прізвище, рік, телефон}

--{Ім'я, телефон}

--{Прізвище, Телефон}

--{Рік, телефон}

--Суперключ {Phone} відповідає першій та другій умові, оскільки він має унікальне значення 
--(у даному випадку всі користувачі можуть мати тільки унікальні телефонні номери). 
--Але чи відповідає він третій умові? Загалом немає, тому що теоретично студент може і не мати телефону. 
--У цьому випадку атрибут Phone буде мати значення NULL, тобто значення не буде.

--Водночас це може залежати від ситуації. 
--Якщо в якійсь системі номер телефону є невід'ємним атрибутом, наприклад, 
--використовується для реєстрації та входу до системи, його можна вважати потенційним ключем. 
--Але в цьому випадку ми розглядаємо загальну ситуацію. 
--І розуміння потенційного ключа необхідно відштовхуватися від конкретної системи, яку визначає база даних.

--І в такому випадку суперключі таблиці не містять потенційного ключа.

--Первинний ключ
--Первинний ключ (primary key) безпосередньо застосовується для ідентифікації рядків таблиці. 
--Він повинен відповідати наступним обмеженням:

--Первинний ключ має бути унікальним весь час

--Він повинен бути присутнім у таблиці і мати значення

--Він повинен часто змінювати своє значення. В ідеалі він взагалі не повинен змінювати значення.

--Як правило, первинний ключ представляє один стовпець таблиці, але може бути складеним і складатися з декількох стовпців.

--Якщо таблиці можна виділити потенційний ключ, його можна використовувати як первинного ключа.

--Якщо ж потенційні ключі відсутні, то для первинного ключа можна додати до сутності спеціальний атрибут, 
--який, як правило, називається Id або має форму [ Ім'я_сутності]Id (наприклад, StudentId), або може мати іншу назву. 
--І зазвичай цей атрибут набуває цілого значення, починаючи з 1.

--Якщо ж у нас є кілька потенційних ключів, то потенційні ключі, які не становлять первинний ключ, є альтернативними ключами (alternative key).

--Наприклад, візьмемо подання користувачів на сайтах з двофакторною авторизацією, 
--де нам обов'язково мати електронну адресу, яка нерідко виступає як логін, і якийсь номер телефону. 
--У цьому випадку таблицю користувачів ми можемо задати за допомогою таких атрибутів:

--Name (ім'я користувача)

--Email (електронна адреса)

--Password (пароль)

--Phone (телефонний номер)

--В даному випадку атрибути Email і Phone є потенційними ключами, вони обов'язкові в рамках системи, що розглядається, і в принципі унікальні. 
--І теоретично, ми можемо використовувати один із цих атрибутів як первинний ключ, тоді другий буде альтернативним ключем. 
--Однак знову ж таки оскільки теоретично значення обох атрибутів можуть змінюватися, 
--то краще все ж таки визначити додатковий атрибут спеціально під первинний ключ.

------------------------
-- Зовнішні ключі та зв'язки

--Бази даних можуть містити таблиці, пов'язані між собою різними зв'язками. Зв'язок (relationship) є асоціацією між сутностями різних типів.

--При виділенні зв'язку виділяють головну або батьківську таблицю (primary key table/master table) та залежну, 
--дочірню таблицю (foreign key table/child table). Дочірня таблиця залежить від батьківської.

--Для організації зв'язку застосовуються зовнішні ключі. 
--Зовнішній ключ являє собою один або кілька стовпців з однієї таблиці, який одночасно є потенційним ключем з іншої таблиці. 
--Зовнішній ключ необов'язково має відповідати первинному ключу з головної таблиці. 
--Хоча, як правило, зовнішній ключ із залежної таблиці вказує на первинний ключ із головної таблиці.

--Зв'язки між таблицями бувають таких типів:

--Один к одному (One to one)

--Один до багатьох

--Багато хто до багатьох (Many to many)

--Зв'язок один до одного
--Цей тип зв'язків зустрічає не часто. І тут об'єкту однієї сутності можна зіставити лише одне об'єкт інший сутності. 
--Наприклад, на деяких сайтах користувач може мати лише один блог. Тобто виникає відношення один користувач – один блог.

--Нерідко цей тип зв'язків передбачає розбиття однієї великої таблиці кілька маленьких. 
--Основна батьківська таблиця в цьому випадку продовжує містити дані, що часто використовуються, 
--а дочірня залежна таблиця зазвичай зберігає дані, які використовуються рідше.

--Щодо цього первинний ключ залежної таблиці в той же час є зовнішнім ключем, який посилається на первинний ключ із головної таблиці.

--Наприклад, таблиця Users представляє користувачів і має такі стовпці:

--UserId (ідентифікатор, первинний ключ)

--Name (ім'я користувача)

--І таблиця Blogs представляє блоги користувачів і має такі стовпці:

--BlogId (ідентифікатор, первинний та зовнішній ключ)

--Name (назва блогу)

--У цьому випадку стовпець BlogId зберігатиме значення зі стовпця UserId з таблиці користувачів. 
--Тобто стовпець BlogId виступатиме одночасно первинним та зовнішнім ключем.

--Зв'язок один до одного в SQL
--Зв'язок один до багатьох
--Це найпоширеніший тип зв'язків. У цьому типі зв'язків кілька рядків із дочірньої таблиці залежать від одного рядка у батьківській таблиці. 
--Наприклад, в одному блозі може бути кілька статей. У цьому випадку таблиця блогів є батьківською, а таблиця статей – дочірньою. 
--Тобто один блог – багато статей. Або інший приклад, у футбольній команді може грати кілька футболістів. 
--І водночас один футболіст одночасно може грати лише в одній команді. Тобто одна команда – багато футболістів.

--Наприклад, нехай буде таблиця Articles, яка представляє статті блогу і яка має такі стовпці:

--ArticleId (ідентифікатор, первинний ключ)

--BlogId (зовнішній ключ)

--Title (назва статті)

--Text (текст статті)

--У цьому випадку стовпець BlogId з таблиці статей зберігатиме значення зі стовпця BlogId з таблиці блогів.

--Зв'язок один до багатьох у SQL
--Зв'язок багато хто до багатьох
--При цьому типі зв'язків один рядок з таблиці А може бути пов'язаний з безліччю рядків з таблиці В. 
--У свою чергу один рядок з таблиці А може бути пов'язаний з безліччю рядків з таблиці А. 
--Типовий приклад - студенти та курси: один студент може відвідувати кілька курсів і відповідно на один курс можуть записатися кілька студентів.

--Інший приклад - статті та теги: для однієї статті можна визначити кілька тегів, а один тег може бути визначений для кількох статей.

--Але в SQL Server на рівні бази даних ми не можемо встановити прямий зв'язок до багатьох між двома таблицями. 
--Це робиться у вигляді допоміжної проміжної таблиці. Іноді дані цієї проміжної таблиці представляють окрему сутність.

--Наприклад, у випадку зі статтями та тегами нехай буде таблиця Tags, яка має два стовпці:

--TagId (ідентифікатор, первинний ключ)

--Text (текст тега)

--Також нехай буде проміжна таблиця ArticleTags з наступними полями:

--TagId (ідентифікатор, первинний та зовнішній ключ)

--ArticleIdId (ідентифікатор, первинний та зовнішній ключ)

--Зв'язок багато хто до багатьох SQL
--Технічно ми отримаємо два зв'язки одним-багатьом. Стовпець TagId із таблиці ArticleTags буде посилатися на стовпець TagId із таблиці Tags. 
--А стовпець ArticleId із таблиці ArticleTags буде посилатися на стовпець ArticleId із таблиці Articles. 
--Тобто стовпці TagId і ArticleId у таблиці ArticleTags являють собою складовий первинний ключ і 
--одночасно є зовнішніми ключами для зв'язку з таблицями Articles і Tags.

--Посилальна цілісність даних
--При зміні первинних і зовнішніх ключів слід дотримуватися такого аспекту, як посилальна цілісність даних (referential integrity). 
--Її основна ідея у тому, щоб дві таблиці у базі даних, які зберігають одні й самі дані, підтримували їх узгодженість. 
--Цілісність даних представляє правильно збудовані відносини між таблицями з коректною установкою посилань між ними. 
--У яких випадках цілісність даних може порушуватися:

--Аномалія вилучення (deletion anomaly). Виникає у разі видалення рядка з головної таблиці. 
--У цьому випадку зовнішній ключ із залежної таблиці продовжує посилатися на віддалений рядок із головної таблиці

--Аномалія вставки (insertion anomaly). Виникає при вставці рядка у залежну таблицю. 
--У цьому випадку зовнішній ключ із залежної таблиці не відповідає первинному ключу жодного з рядків із головної таблиці.

--Аномалії оновлення (update anomaly). При подібній аномалії кілька рядків однієї таблиці можуть містити дані, 
--які належать одному й тому об'єкту. При зміні даних в одному рядку вони можуть суперечити даними з іншого рядка.

--Аномалія видалення
--Для вирішення аномалії видалення зовнішнього ключа слід встановлювати одне з двох обмежень:

--Якщо рядок із залежної таблиці обов'язково вимагає наявності рядка із головної таблиці, 
--то для зовнішнього ключа встановлюється каскадне видалення. Тобто при видаленні рядка із головної таблиці 
--відбувається видалення зв'язаного рядка (рядків) із залежної таблиці.

--Якщо рядок із залежної таблиці допускає відсутність зв'язку з рядком із головної таблиці (тобто такий зв'язок необов'язковий), 
--то для зовнішнього ключа при видаленні зв'язаного рядка із головної таблиці задається встановлення значення NULL. 
--У цьому стовпець зовнішнього ключа повинен допускати значення NULL.

--Аномалія вставки
--Для вирішення аномалії вставки при додаванні до залежної таблиці даних стовпець, який представляє зовнішній ключ, 
--повинен допускати значення NULL. І таким чином, якщо об'єкт, що додається, не має зв'язку з головною таблицею, 
--то в стовпці зовнішнього ключа стоятиме значення NULL.

--Аномалії оновлення
--Для вирішення проблеми аномалії поновлення застосовується нормалізація, яка буде розглянута далі.

-------------------------

-- Нормалізація

--Нормалізація представляє процес поділу даних за окремими таблицями. 
--Нормалізація усуває надмірність даних (data redundancy) і цим уникнути порушення цілісності даних за її зміні, 
--тобто уникнути аномалій зміни (update anomaly).

--Як правило, нормалізація переважно застосовується при висхідному підході проектуванні бази даних, 
--тобто коли ми всі атрибути, які треба зберегти в бд, групуємо по суті, для яких потім створюються таблиці. 
--Однак при низхідному підході, коли спочатку виявляються сутності, а потім їх атрибути та зв'язки між ними, 
--нормалізація також може застосовуватися, наприклад, для перевірки коректності спроектованих таблиць.

--У ненормалізованій формі таблиця може зберігати інформацію про дві і більше сутності. 
--Також вона може містити стовпці, що повторюються. Також стовпці можуть зберігати значення, що повторюються. 
--У нормалізованій формі кожна таблиця зберігає інформацію лише про одну сутність.

--Нормалізація передбачає застосування нормальних форм структури даних. 
--Існує 7 нормальних форм. Кожна нормальна форма (за винятком першої) має на увазі, 
--що до даних вже було застосовано попередню нормальну форму. 
--Наприклад, перш ніж застосувати третю нормальну форму даних повинна бути застосована друга нормальна форма. 
--І, строго кажучи, база даних вважається нормалізованою, якщо до неї застосовується третя нормальна форма і вище.

--Перша нормальна форма (1NF) передбачає, що дані, що зберігаються на перетині рядків і стовпців повинні представляти скалярне значення, 
--а таблиці не повинні містити рядків, що повторюються.

--Друга нормальна форма (2NF) передбачає, кожен стовпець, який є ключем, повинен залежати від первинного ключа.

--Третя нормальна форма (3NF) передбачає, кожен стовпець, який є ключем, повинен залежати тільки від первинного ключа.

--Нормальна форма Бойса-Кодда (BCNF) є трохи суворішою версією третьої нормальної форми.

--Четверта нормальна форма (4NF) застосовується для усунення багатозначних залежностей (multivalued dependencies) - 
--таких залежностей, де стовпець з первинним ключем має зв'язок один-багатьом зі стовпцем, який не є ключем. 
--Ця нормальна форма усуває некоректні відносини багато-багатьом.

--П'ята нормальна форма (5NF) поділяє таблиці більш малі таблиці усунення надмірності даних. Розбиття йде доти, 
--доки не можна буде відтворити оригінальну таблицю шляхом об'єднання малих таблиць.

--Шоста нормальна форма (domain key normal form/6NF). 
--Кожне обмеження зв'язків між таблицями повинно залежати тільки від обмежень ключа та обмежень домену, 
--де домен представляє набір допустимих значень для стовпця. 
--Ця форма запобігає додаванню неприпустимих даних шляхом встановлення обмеження лише на рівні відносин між таблицями, 
--але з рівні таблиць чи стовпців. Ця форма, зазвичай, не застосовна лише на рівні СУБД, зокрема й у SQL Server.

--Функціональна залежність
--Ключовим поняттям нормалізації є функціональна залежність . Функціональна залежність визначає зв'язок між атрибутами відносини. 
--Наприклад, якщо атрибут В функціонально залежить від атрибуту А (А → В), кожне значення атрибуту А пов'язане лише з одним значенням атрибуту В. 
--Причому атрибути А і можуть складатися з одного або декількох атрибутів. 
--Тобто, якщо два рядки мають одне й те саме значення атрибуту А, то вони обов'язково мають одне й те саме значення атрибуту В. 
--При цьому для одного значення атрибуту можуть існувати кілька різних значень атрибуту А. Атрибут А в цій залежності ще називається детермінантом .

--Наприклад, візьмемо наступну таблицю, яка представляє університетські курси:

--курс	вчитель	Позиція
--Математика	Сміт	професор
--Алгорити	Адамс	Помічник
--JavaScript	Адамс	Помічник
--Тут атрибут Teacher функціонально залежить від атрибута Course (Course → Teacher). Тобто знаючи назву курсу, ми можемо визначити його викладача. 
--І в цьому випадку можна говорити, що між атрибутами Course та Teacher є зв'язок 1:1, а між Teacher та Course зв'язок 1:N, 
--оскільки є кілька курсів, які може вести один викладач. При цьому атрибут Course не залежить від атрибута Teacher.

--Крім того, тут можна простежити ще дві функціональні залежності. Зокрема, атрибут Position залежить від атрибута Teacher (Teacher → Position). 
--Знаючи ім'я викладача, ми можемо визначити його посаду.

--А також атрибут Position функціонально залежить від атрибуту Course - знаючи назву курсу, ми можемо сказати посаду викладача.

--У таблиці у нормалізованій базі даних єдиним детермінантом має бути атрибут, який є первинним ключем. 
--А решта атрибутів повинна функціонально залежати від первинного ключа.

--Наприклад, в даному випадку ми можемо взяти як первинний ключ назву курсу з урахуванням, що курси можуть мати тільки унікальні назви. 
--Однак посада викладача в даному випадку залежатиме одразу від двох атрибутів – від Course та Teacher. 
--І подібні залежності можуть свідчити, що база даних і саме таблиця курсів має недоліки у проектуванні і може бути джерелом аномалій оновлення.

----
-- Перша нормальна форма

--Перша нормальна форма передбачає, що таблиця не повинна містити стовпців, що повторюються, або таких стовпців, які містять набори значень. 
--Ненормалізована таблиця в цьому випадку може містити одну або кілька груп даних, що повторюються. 
--Група, що повторюється, - це група з одного або декількох атрибутів таблиці,
--в якій можлива наявність декількох значень для ключового атрибута таблиці.

--Підсумком застосування першої форми має стати наявність для одного атрибуту сутності лише одного стовпця в таблиці, 
--який повинен містити скалярне значення.

--Існують два походи до переходу до ненормалізованої таблиці до першої нормальної форми. Перший спосіб називається вирівнюванням або flattaning. 
--Він передбачає декомпозицію рядка з групами даних, що повторюються, при якому для кожної групи, що повторюється, створюється свій рядок. 
--Отримана в результаті таблиця міститиме атомарні значення кожного з атрибутів. Хоча водночас цей підхід збільшить надмірність даних.

--Другий підхід передбачає, що один атрибут або група атрибутів призначаються ключем ненормалізованої таблиці, а потім групи, 
--що повторюються, видаляються з таблиці і поміщаються в окрему таблицю разом з копіями ключа з вихідної таблиці.

-- Друга нормальна форма

--У другій нормальній формі кожен стовпець у таблиці, який є ключем, повинен залежати від ключа .

--Ключовий момент другої нормальної форми – повна функціональна залежність. 
--Вона передбачає, що атрибут В повністю функціонально залежить від атрибуту А, 
--якщо атрибут В функціонально залежить від повного значення атрибуту А, а не від будь-якого підмножини значень з атрибуту А. 
--Тобто якщо атрибут А складають кілька значень, скажімо, А1 і А2, то атрибут повністю функціонально залежить від А, 
--якщо він залежить і від А1 і від А2 (А1, А2 → В).

--Якщо атрибут залежить тільки від будь-якого підмножини з атрибуту А, наприклад, тільки від А1, то має місце часткова функціональна залежність.

--Ця форма застосовується до таблиць, які мають складовий первинний ключ, тобто де первинний ключ складається з декількох атрибутів. 
--Якщо таблиці несоставной первинний ключ, то цьому випадку вважається, 
--що й інші атрибути автоматично перебувають у повної функціональної залежності від первинного ключа.

--Друга нормальна форма застосовується лише до таблицям, які у першій нормальній формі. Після застосування другої форми, 
--всі стовпці таблиці залежать від первинного ключа.

-- Третя нормальна форма

--Третя нормальна форма передбачає, що кожен стовпець, що не є ключем, повинен залежати тільки від стовпця, який є ключем, 
--тобто має бути відсутня транзитивна функціональна залежність (transitive functional dependency)

--Транзитивна функціональна залежність виражається так: А → В і В → С. Тобто атрибут С транзитивно залежить від атрибуту А, 
--якщо атрибут залежить від атрибуту В, а атрибут залежить від атрибуту А (за умови, що атрибут А функціонально не залежить ні від атрибуту, 
--ні від атрибуту С).

--Якщо стовпець залежить не тільки від первинного ключа, то цей стовпець знаходиться не в тій таблиці, в якій він повинен знаходитися, 
--або є похідним від інших стовпців.

--Для нормалізації з вихідної таблиці атрибути, які у транзитивної залежності від ключа, 
--виносяться в окрему таблицю з копією того атрибута, від якого вони безпосередньо залежать.

--При застосуванні третьої нормальної форми таблиця повинна бути у другій нормальній формі. 
--3NF дозволяє значно знизити надмірність даних.

----------------------
-- Агрегатні функції

--Агрегатні функції виконують обчислення над значеннями набору рядків. У T-SQL є такі агрегатні функції:
--AVG : знаходить середнє значення
--SUM : знаходить суму значень
--MIN : знаходить найменше значення
--MAX : знаходить найбільше значення
--COUNT : знаходить кількість рядків у запиті

--Як аргумент всі агрегатні функції приймають вираз, який представляє критерій для визначення значень. 
--Найчастіше, як вираз виступає назва стовпця, над значеннями якого треба проводити обчислення.

--Вирази у функціях AVG та SUM мають бути числовими. Вираз у функціях MIN , MAX та COUNT може представляти числове чи рядкове значення чи дату.

--Усі агрегатні функції крім COUNT(*)ігнорують значення NULL.

--DROP table Products
CREATE TABLE Products
(
    Id INT IDENTITY PRIMARY KEY,
    ProductName NVARCHAR(30) NOT NULL,
    Manufacturer NVARCHAR(20) NOT NULL,
    ProductCount INT DEFAULT 0,
    Price MONEY NOT NULL
);
  
INSERT INTO Products 
VALUES
('iPhone 6', 'Apple', 3, 36000),
('iPhone 6S', 'Apple', 2, 41000),
('iPhone 7', 'Apple', 5, 52000),
('Galaxy S8', 'Samsung', 2, 46000),
('Galaxy S8 Plus', 'Samsung', 1, 56000),
('Mi6', 'Xiaomi', 5, 28000),
('OnePlus 5', 'OnePlus', 6, 38000)
-- 	
SELECT AVG(Price) AS Average_Price FROM Products
--
SELECT AVG(Price) FROM Products
WHERE Manufacturer='Apple'
--	
SELECT AVG(Price * ProductCount) FROM Products
--
SELECT COUNT(*) FROM Products
--
SELECT COUNT(Manufacturer) FROM Products
--
SELECT MIN(Price) FROM Products
--
SELECT MAX(Price) FROM Products
--
SELECT SUM(ProductCount) FROM Products
--
SELECT SUM(ProductCount * Price) FROM Products
--
SELECT AVG(DISTINCT ProductCount) AS Average_Price FROM Products
--
SELECT AVG(ALL ProductCount) AS Average_Price FROM Products
--
SELECT COUNT(*) AS ProdCount,
       SUM(ProductCount) AS TotalCount,
       MIN(Price) AS MinPrice,
       MAX(Price) AS MaxPrice,
       AVG(Price) AS AvgPrice
FROM Products
-----------------------------
-- Оператори GROUP BY та HAVING

--Для групування даних у T-SQL застосовуються оператори GROUP BY та HAVING , для використання яких застосовується наступний формальний синтаксис:

--SELECT столбцы
--FROM таблица
--[WHERE условие_фильтрации_строк]
--[GROUP BY столбцы_для_группировки]
--[HAVING условие_фильтрации_групп]
--[ORDER BY столбцы_для_сортировки]

--
-- Оператор GROUP BY визначає, як рядки групуватимуться.
SELECT Manufacturer, COUNT(*) AS ModelsCount
FROM Products
GROUP BY Manufacturer

-- Перший стовпець у виразі SELECT - Manufacturer представляє назву групи, а другий стовпець - 
-- ModelsCount представляє результат функції Count, яка обчислює кількість рядків групи.

--Варто враховувати, що будь-який стовпець, який використовується у виразі SELECT 
--(не рахуючи стовпців, які зберігають результат агрегатних функцій), повинні бути вказані після оператора GROUP BY. 
--Так, наприклад, у разі вище стовпець Manufacturer зазначений і у виразі SELECT, і у виразі GROUP BY.

--І якщо у виразі SELECT проводиться вибірка по одному або декільком стовпцям і також використовуються агрегатні функції, 
--необхідно використовувати вираз GROUP BY. Так, наступний приклад працювати не буде, тому що він не містить виразу угруповання:

SELECT Manufacturer, COUNT(*) AS ModelsCount
FROM Products

--
SELECT Manufacturer, ProductCount, COUNT(*) AS ModelsCount
FROM Products
GROUP BY Manufacturer, ProductCount

--Оператор GROUP BYможе виконувати угруповання за безліччю стовпців.

--Якщо стовпець, за яким проводиться угруповання, містить значення NULL, то рядки зі значенням NULL становитимуть окрему групу.

--Слід враховувати, що вираз GROUP BYмає йти після виразу WHERE, але до виразу ORDER BY:

SELECT Manufacturer, COUNT(*) AS ModelsCount
FROM Products
WHERE Price > 30000
GROUP BY Manufacturer
ORDER BY ModelsCount DESC

--Фільтрування груп. HAVING
--Оператор HAVING визначає, які групи будуть включені у вихідний результат, тобто виконує фільтрацію груп.

--Застосування HAVING багато в чому аналогічне до застосування WHERE. 
--Тільки WHERE застосовується до фільтрації рядків, то HAVING використовується для фільтрації груп.

--Наприклад, знайдемо всі групи товарів за виробниками, для яких визначено понад 1 модель:

SELECT Manufacturer, COUNT(*) AS ModelsCount
FROM Products
GROUP BY Manufacturer
HAVING COUNT(*) > 1

-- При цьому в одній команді ми можемо використовувати вирази WHERE та HAVING:

SELECT Manufacturer, COUNT(*) AS ModelsCount
FROM Products
WHERE Price * ProductCount > 80000
GROUP BY Manufacturer
HAVING COUNT(*) > 1

--Тобто в даному випадку спочатку фільтруються рядки: вибираються ті товари, загальна вартість яких більша за 80000. 
--Потім вибрані товари групуються за виробниками. І далі фільтруються самі групи - вибираються ті групи, які містять понад 1 модель.

--Якщо при цьому необхідно провести сортування, вираз ORDER BY йде після виразу HAVING:

SELECT Manufacturer, COUNT(*) AS Models, SUM(ProductCount) AS Units
FROM Products
WHERE Price * ProductCount > 80000
GROUP BY Manufacturer
HAVING SUM(ProductCount) > 2
ORDER BY Units DESC

--В даному випадку угруповання йде по виробниках, а також вибирається кількість моделей для кожного виробника (Models) 
--та загальна кількість усіх товарів по всіх цих моделях (Units). Наприкінці групи сортуються за кількістю товарів зі спадання.

--------------
-- Розширення SQL Server для групування

-- Додатково до стандартних операторів GROUP BY і HAVING SQL Server 
-- підтримує ще чотири спеціальні розширення для групування даних: ROLLUP , CUBE , GROUPING SETS та OVER .

-- Оператор ROLLUP додає рядок, що підсумовує, в результуючий набір:

SELECT Manufacturer, COUNT(*) AS Models, SUM(ProductCount) AS Units
FROM Products
GROUP BY Manufacturer WITH ROLLUP

-- Альтернативний синтаксис запиту, який можна використовувати, починаючи з версії MS SQL Server 2008:

SELECT Manufacturer, COUNT(*) AS Models, SUM(ProductCount) AS Units
FROM Products
GROUP BY ROLLUP(Manufacturer)

-- При групуванні за кількома критеріями ROLLUP буде створювати підсумовуючий рядок для кожної з підгруп:

SELECT Manufacturer, COUNT(*) AS Models, SUM(ProductCount) AS Units
FROM Products
GROUP BY Manufacturer, ProductCount WITH ROLLUP

-- При сортуванні за допомогою ORDER BY слід враховувати, що воно застосовується вже після додавання рядка, що підсумовує.

-- CUBE схожий на ROLLUP за тим винятком, що CUBE додає підсумовують рядки для кожної комбінації груп.

SELECT Manufacturer, COUNT(*) AS Models, SUM(ProductCount) AS Units
FROM Products
GROUP BY Manufacturer, ProductCount WITH CUBE

-- Оператор GROUPING SETS аналогічно ROLLUP і CUBE додає сумуючий рядок для груп. Але при цьому він не включає самі групи:

SELECT Manufacturer, COUNT(*) AS Models, ProductCount
FROM Products
GROUP BY GROUPING SETS(Manufacturer, ProductCount)

-- При цьому його можна поєднувати з ROLLUP або CUBE. 
-- Наприклад, крім підсумовувальних рядків по кожній із груп додамо підсумовуючий рядок для всіх груп:

SELECT Manufacturer, COUNT(*) AS Models, 
        ProductCount, SUM(ProductCount) AS Units
FROM Products
GROUP BY GROUPING SETS(ROLLUP(Manufacturer), ProductCount)

-- За допомогою дужок можна визначити складніші сценарії угруповання:

SELECT Manufacturer, COUNT(*) AS Models, 
        ProductCount, SUM(ProductCount) AS Units
FROM Products
GROUP BY GROUPING SETS((Manufacturer, ProductCount), ProductCount)

-- Вираз OVER дозволяє підсумовувати дані, при цьому повертаючи рядки, які використовувалися для отримання сумованих даних. 
-- Наприклад, знайдемо кількість моделей та загальну кількість товарів цих моделей за виробником:

SELECT ProductName, Manufacturer, ProductCount,
        COUNT(*) OVER (PARTITION BY Manufacturer) AS Models,
        SUM(ProductCount) OVER (PARTITION BY Manufacturer) AS Units
FROM Products

--Вираз OVER ставиться після агрегатної функції, потім у дужках йде вираз PARTITION BY і стовпець, яким виконується угруповання.

--Тобто в даному випадку ми вибираємо назву моделі, виробника, 
--кількість одиниць моделі та додаємо до цього кількість моделей для даного виробника та загальну кількість одиниць усіх моделей виробника

------------------------
-- Виконання підзапитів

-- T-SQL підтримує функціональність підзапитів (subquery), тобто таких запитів, які можуть бути вбудовані в інші запити.
create database productsdb
go
USE productsdb;
 
CREATE TABLE Products
(
    Id INT IDENTITY PRIMARY KEY,
    ProductName NVARCHAR(30) NOT NULL,
    Manufacturer NVARCHAR(20) NOT NULL,
    ProductCount INT DEFAULT 0,
    Price MONEY NOT NULL
);
CREATE TABLE Customers
(
    Id INT IDENTITY PRIMARY KEY,
    FirstName NVARCHAR(30) NOT NULL
);
CREATE TABLE Orders
(
    Id INT IDENTITY PRIMARY KEY,
    ProductId INT NOT NULL REFERENCES Products(Id) ON DELETE CASCADE,
    CustomerId INT NOT NULL REFERENCES Customers(Id) ON DELETE CASCADE,
    CreatedAt DATE NOT NULL,
    ProductCount INT DEFAULT 1,
    Price MONEY NOT NULL
);

--
INSERT INTO Products 
VALUES ('iPhone 6', 'Apple', 2, 36000),
('iPhone 6S', 'Apple', 2, 41000),
('iPhone 7', 'Apple', 5, 52000),
('Galaxy S8', 'Samsung', 2, 46000),
('Galaxy S8 Plus', 'Samsung', 1, 56000),
('Mi 5X', 'Xiaomi', 2, 26000),
('OnePlus 5', 'OnePlus', 6, 38000)
 
INSERT INTO Customers VALUES ('Tom'), ('Bob'),('Sam')
 
INSERT INTO Orders 
VALUES
( 
    (SELECT Id FROM Products WHERE ProductName='Galaxy S8'), 
    (SELECT Id FROM Customers WHERE FirstName='Tom'),
    '2017-07-11',  
    2, 
    (SELECT Price FROM Products WHERE ProductName='Galaxy S8')
),
( 
    (SELECT Id FROM Products WHERE ProductName='iPhone 6S'), 
    (SELECT Id FROM Customers WHERE FirstName='Tom'),
    '2017-07-13',  
    1, 
    (SELECT Price FROM Products WHERE ProductName='iPhone 6S')
),
( 
    (SELECT Id FROM Products WHERE ProductName='iPhone 6S'), 
    (SELECT Id FROM Customers WHERE FirstName='Bob'),
    '2017-07-11',  
    1, 
    (SELECT Price FROM Products WHERE ProductName='iPhone 6S')
)

--Тут інтерес представляє додавання елементів до таблиці Orders. Наприклад, перше замовлення було зроблено покупцем Tom на товар Galaxy S8. 
--Відповідно до таблиці Orders нам треба зберегти інформацію про замовлення, 
--де поле ProductId вказує на Id товару Galaxy S8, поле Price – на його ціну, а поле CustomerId – на Id покупця Tom. 
--Але на момент написання запиту нам може бути невідомим ні Id покупця, ні Id товару, ні ціна товару. У цьому випадку можна виконати підзапит.

--Підзапит виконує команду SELECT і полягає у дужках. У цьому випадку при додаванні одного товару виконується три подзапроса. 
--Кожен підзапит повертає одного скалярного значення, наприклад, числовий ідентифікатор.

--В даному випадку підзапити виконувались до іншої таблиці, але можуть виконуватися і до тієї, до якої викликається основний запит. 
--Наприклад, знайдемо товари з таблиці Products, які мають мінімальну ціну:

SELECT *
FROM Products
WHERE Price = (SELECT MIN(Price) FROM Products)

--
SELECT *
FROM Products
WHERE Price > (SELECT AVG(Price) FROM Products)

--Корелюючі підзапити
--Підзапити бувають корелюючими та некорелюючими. 
--У прикладах вище команди SELECT виконували фактично один підзапит для всієї команди, 
--наприклад, підзапит повертає мінімальну або середню ціну, яка не зміниться, скільки ми рядків не вибирали в основному запиті. 
--Тобто результат підзапиту не залежав від рядків, які вибираються переважно запитом. 
--І такий підзапит виконується один раз для всього зовнішнього запиту.

--Але існують коррелирующие підзапити (correlated subquery), результати яких залежить від рядків, які вибираються переважно запиті.

--Наприклад, виберемо всі замовлення з таблиці Orders, додавши до них інформацію про товар:

SELECT  CreatedAt, 
        Price, 
        (SELECT ProductName FROM Products 
        WHERE Products.Id = Orders.ProductId) AS Product
FROM Orders

-- Тут для кожного рядка з таблиці Orders буде виконуватися запит, результат якого залежить від стовпця ProductId. 
-- І кожен підзапит може повертати різні дані.

--Корелюючий підзапит може виконуватися і тієї ж таблиці, до якої виконується основний запит. 
--Наприклад, виберемо з таблиці Products ті товари, вартість яких вища за середню ціну товарів для даного виробника:

SELECT ProductName,
       Manufacturer,
       Price, 
        (SELECT AVG(Price) FROM Products AS SubProds 
         WHERE SubProds.Manufacturer=Prods.Manufacturer)  AS AvgPrice
FROM Products AS Prods
WHERE Price > 
    (SELECT AVG(Price) FROM Products AS SubProds 
     WHERE SubProds.Manufacturer=Prods.Manufacturer)

--У даному випадку визначено два корелюючі підзапити. Перше підзапит визначає специфікацію стовпця AvgPrice. 
--Він буде виконуватися для кожного рядка, що витягується з таблиці Products. 
--У підзапит передається виробник товару та на його основі вибирається середня ціна для товарів саме цього виробника. 
--І оскільки виробник у товарів може відрізнятися, то результат підзапиту в кожному випадку також може відрізнятися.

--Другий підзапит аналогічний, тільки він використовується для фільтрації видобутих з таблиці Products. 
--І він буде виконуватися для кожного рядка.

--Щоб уникнути двоїстості під час фільтрації в підзапиті при порівнянні виробників ( SubProds.Manufacturer=Prods.Manufacturer) 
--для зовнішньої вибірки встановлено псевдонім Prods, а для вибірки з підзапитів визначено псевдонім SubProds.

--Слід враховувати, що коррелирующие підзапити виконуються кожної окремої рядки вибірки, 
--то виконання таких підзапитів може уповільнювати виконання всього запиту загалом.

-----------------
--Підзапити у SELECT

--У виразі SELECT ми можемо вводити підзапити чотирма способами:

--Використовувати за умови у виразі WHERE

--Використовувати за умови у виразі HAVING

--Використовувати як таблицю для вибірки у виразі FROM

--Використовувати як специфікацію стовпця у виразі SELECT

--
SELECT *
FROM Products
WHERE Price > (SELECT AVG(Price) FROM Products)

--
SELECT * FROM CUSTOMERS
WHERE Id NOT IN (SELECT CustomerId FROM Orders)

--
--При використанні операторів порівняння підзапити повинні повертати одне скалярне значення. 
--Але іноді виникає потреба отримати набір значень. 
--Щоб при використанні в операторах порівняння підзапит міг повертати набір значень, 
--перед ним необхідно використовувати один із операторів: ALL , SOME або ANY .

--При використанні ключового слова ALL умова в операції порівняння повинна бути правильною для всіх значень, які повертаються під запитом.
-- Наприклад, знайдемо всі товари, ціна яких менша ніж у будь-якого товару фірми Apple:
SELECT * FROM Products
WHERE Price < ALL(SELECT Price FROM Products WHERE Manufacturer='Apple')

-- Якби ми в даному випадку опустили ключове слово ALL, то ми зіткнулися б з помилкою.

-- У той же час подібний запит набагато простіше переписати іншим чином:
SELECT * FROM Products
WHERE Price < (SELECT MIN(Price) FROM Products WHERE Manufacturer='Apple')

--При застосуванні ключових слів ANY і SOME умова в операції порівняння має бути істинною для хоча б одного зі значень, що повертаються підзапитом. 
--За діяльністю обидва ці оператори аналогічні, тому можна застосовувати будь-яке з них. 
--Наприклад, у наступному випадку отримаємо товари, які коштують менше дорогого товару компанії Apple:

SELECT * FROM Products
WHERE Price < ANY(SELECT Price FROM Products WHERE Manufacturer='Apple')

-- or
SELECT * FROM Products
WHERE Price < (SELECT MAX(Price) FROM Products WHERE Manufacturer='Apple')

-- Підзапит як специфікація стовпця
SELECT *, 
(SELECT ProductName FROM Products WHERE Id=Orders.ProductId) AS Product 
FROM Orders

-- Підзапити у команді INSERT
INSERT INTO Orders (ProductId, CustomerId, CreatedAt, ProductCount, Price)
VALUES
( 
    (SELECT Id FROM Products WHERE ProductName='Galaxy S8'), 
    (SELECT Id FROM Customers WHERE FirstName='Tom'),
    '2017-07-11',  
    2, 
    (SELECT Price FROM Products WHERE ProductName='Galaxy S8')
)

-- Підзапити у команді UPDATE
--У команді UPDATE підзапити можуть застосовуватись:

--Як значення, що встановлюється після оператора SET

--Як частина умови у виразі WHERE

UPDATE Orders
SET ProductCount = ProductCount + 2
WHERE CustomerId=(SELECT Id FROM Customers WHERE FirstName='Tom')

-- or
UPDATE Orders
SET Price = (SELECT Price FROM Products WHERE Id=Orders.ProductId) + 2000
WHERE Id=1

-- Підзапити у команді DELETE
DELETE FROM Orders
WHERE ProductId=(SELECT Id FROM Products WHERE ProductName='Galaxy S8')
AND CustomerId=(SELECT Id FROM Customers WHERE FirstName='Bob')

--------------------------
--Оператор EXISTS дозволяє перевірити, чи повертає підзапит будь-яке значення. 
--Як правило, цей оператор використовується для індикації того, що будь-який рядок задовольняє умову. 
--Тобто фактично оператор EXISTS не повертає рядки, а лише вказує, що в базі даних є щонайменше один рядок, 
--який відповідає даному запиту. 
--Оскільки повернення набору рядків не відбувається, підзапити з подібним оператором виконуються досить швидко.

-- WHERE [NOT] EXISTS (подзапрос)

-- Наприклад, знайдемо всіх покупців із таблиці Customer, які робили замовлення:
SELECT *
FROM Customers
WHERE EXISTS (SELECT * FROM Orders 
                  WHERE Orders.CustomerId = Customers.Id)

-- Інший приклад - знайдемо всі товари з таблиці Products, на які не було замовлень у таблиці Orders:
SELECT *
FROM Products
WHERE NOT EXISTS (SELECT * FROM Orders WHERE Products.Id = Orders.ProductId)

-- Варто зазначити, що для отримання подібного результату могли б використовувати і опеатор IN :
SELECT *
FROM Products
WHERE Id NOT IN (SELECT ProductId FROM Orders)

-- Але оскільки при застосуванні EXISTS не відбувається вибірка рядків, його використання більш оптимально і ефективно, 
-- ніж використання оператора IN.

-----------------------------------------
--З'єднання таблиць

--Неявне з'єднання таблиць

--Для даних з різних таблиць ми можемо використовувати стандартну команду SELECT. 
--Допустимо, у нас є такі таблиці, які пов'язані між собою зв'язками:
 
CREATE TABLE Products
(
    Id INT IDENTITY PRIMARY KEY,
    ProductName NVARCHAR(30) NOT NULL,
    Manufacturer NVARCHAR(20) NOT NULL,
    ProductCount INT DEFAULT 0,
    Price MONEY NOT NULL
);
CREATE TABLE Customers
(
    Id INT IDENTITY PRIMARY KEY,
    FirstName NVARCHAR(30) NOT NULL
);
CREATE TABLE Orders
(
    Id INT IDENTITY PRIMARY KEY,
    ProductId INT NOT NULL REFERENCES Products(Id) ON DELETE CASCADE,
    CustomerId INT NOT NULL REFERENCES Customers(Id) ON DELETE CASCADE,
    CreatedAt DATE NOT NULL,
    ProductCount INT DEFAULT 1,
    Price MONEY NOT NULL
);

go

INSERT INTO Products 
VALUES ('iPhone 6', 'Apple', 2, 36000),
('iPhone 6S', 'Apple', 2, 41000),
('iPhone 7', 'Apple', 5, 52000),
('Galaxy S8', 'Samsung', 2, 46000),
('Galaxy S8 Plus', 'Samsung', 1, 56000),
('Mi 5X', 'Xiaomi', 2, 26000),
('OnePlus 5', 'OnePlus', 6, 38000)
 
INSERT INTO Customers VALUES ('Tom'), ('Bob'),('Sam')
 
INSERT INTO Orders 
VALUES
( 
    (SELECT Id FROM Products WHERE ProductName='Galaxy S8'), 
    (SELECT Id FROM Customers WHERE FirstName='Tom'),
    '2017-07-11',  
    2, 
    (SELECT Price FROM Products WHERE ProductName='Galaxy S8')
),
( 
    (SELECT Id FROM Products WHERE ProductName='iPhone 6S'), 
    (SELECT Id FROM Customers WHERE FirstName='Tom'),
    '2017-07-13',  
    1, 
    (SELECT Price FROM Products WHERE ProductName='iPhone 6S')
),
( 
    (SELECT Id FROM Products WHERE ProductName='iPhone 6S'), 
    (SELECT Id FROM Customers WHERE FirstName='Bob'),
    '2017-07-11',  
    1, 
    (SELECT Price FROM Products WHERE ProductName='iPhone 6S')
)

go

SELECT * FROM Orders, Customers
--При такій вибірці для кожного рядка з таблиці Orders поєднуватиметься з кожним рядком з таблиці Customers. Тобто вийде перехресне сполучення. 
--Наприклад, в Orders три рядки, а в Customers те ж три рядки, отже ми отримаємо 3*3 = 9 рядків

--
SELECT * FROM Orders, Customers
WHERE Orders.CustomerId = Customers.Id

--
SELECT Customers.FirstName, Products.ProductName, Orders.CreatedAt 
FROM Orders, Customers, Products
WHERE Orders.CustomerId = Customers.Id AND Orders.ProductId=Products.Id

--
SELECT C.FirstName, P.ProductName, O.CreatedAt 
FROM Orders AS O, Customers AS C, Products AS P
WHERE O.CustomerId = C.Id AND O.ProductId=P.Id

-- or
SELECT C.FirstName, P.ProductName, O.*
FROM Orders AS O, Customers AS C, Products AS P
WHERE O.CustomerId = C.Id AND O.ProductId=P.Id

-----
-- INNER JOIN

--SELECT столбцы
--FROM таблица1
--    [INNER] JOIN таблица2
--    ON условие1
--    [[INNER] JOIN таблица3
--    ON условие2]

--Після оператора JOIN йде назва другої таблиці, з якої треба додати дані у вибірку. 
--Перед JOIN може використовуватися необов'язкове ключове слово INNER . Його наявність чи відсутність ні на що не впливає. 
--Після ключового слова ON вказується умова з'єднання. Ця умова встановлює, як дві таблиці порівнюватимуть. 
--У більшості випадків для з'єднання застосовується первинний ключ головної таблиці та зовнішній ключ залежної таблиці.

SELECT Orders.CreatedAt, Orders.ProductCount, Products.ProductName 
FROM Orders
JOIN Products ON Products.Id = Orders.ProductId

--
SELECT O.CreatedAt, O.ProductCount, P.ProductName 
FROM Orders AS O
JOIN Products AS P
ON P.Id = O.ProductId

--
SELECT Orders.CreatedAt, Customers.FirstName, Products.ProductName 
FROM Orders
JOIN Products ON Products.Id = Orders.ProductId
JOIN Customers ON Customers.Id=Orders.CustomerId

--
SELECT Orders.CreatedAt, Customers.FirstName, Products.ProductName 
FROM Orders
JOIN Products ON Products.Id = Orders.ProductId
JOIN Customers ON Customers.Id=Orders.CustomerId
WHERE Products.Price < 45000
ORDER BY Customers.FirstName

--
SELECT Orders.CreatedAt, Customers.FirstName, Products.ProductName 
FROM Orders
JOIN Products ON Products.Id = Orders.ProductId AND Products.Manufacturer='Apple'
JOIN Customers ON Customers.Id=Orders.CustomerId
ORDER BY Customers.FirstName

--При використанні оператора JOIN слід враховувати, що процес з'єднання таблиць може бути ресурсомістким, тому слід з'єднувати лише таблиці, 
--дані з яких дійсно необхідні. 
--Чим більше таблиць з'єднується, тим більше знижується продуктивність.

-------------------
-- OUTER JOIN

--SELECT столбцы
--FROM таблица1
--    {LEFT|RIGHT|FULL} [OUTER] JOIN таблица2 ON условие1
--    [{LEFT|RIGHT|FULL} [OUTER] JOIN таблица3 ON условие2]...

--Перед оператором JOIN вказується одне з ключових слів LEFT , RIGHT або FULL , які визначають тип з'єднання:

--LEFT : вибірка міститиме всі рядки з першої або лівої таблиці

--RIGHT : вибірка міститиме всі рядки з другої або правої таблиці

--FULL : вибірка міститиме всі рядки з обох таблиць

--Також перед оператором JOIN може вказуватись ключове слово OUTER , але його застосування необов'язкове. 
--Далі після JOIN вказується таблиця, що приєднується, а потім йде умова з'єднання.

SELECT FirstName, CreatedAt, ProductCount, Price, ProductId 
FROM Orders LEFT JOIN Customers 
ON Orders.CustomerId = Customers.Id

-- INNER JOIN
SELECT FirstName, CreatedAt, ProductCount, Price 
FROM Customers JOIN Orders 
ON Orders.CustomerId = Customers.Id
 
--LEFT JOIN
SELECT FirstName, CreatedAt, ProductCount, Price 
FROM Customers LEFT JOIN Orders 
ON Orders.CustomerId = Customers.Id

--
SELECT FirstName, CreatedAt, ProductCount, Price, ProductId 
FROM Orders RIGHT JOIN Customers 
ON Orders.CustomerId = Customers.Id

--
SELECT Customers.FirstName, Orders.CreatedAt, 
       Products.ProductName, Products.Manufacturer
FROM Orders 
LEFT JOIN Customers ON Orders.CustomerId = Customers.Id
LEFT JOIN Products ON Orders.ProductId = Products.Id

--
SELECT Customers.FirstName, Orders.CreatedAt, 
       Products.ProductName, Products.Manufacturer
FROM Orders 
LEFT JOIN Customers ON Orders.CustomerId = Customers.Id
LEFT JOIN Products ON Orders.ProductId = Products.Id
WHERE Products.Price < 45000
ORDER BY Orders.CreatedAt

--
SELECT FirstName FROM Customers
LEFT JOIN Orders ON Customers.Id = Orders.CustomerId
WHERE Orders.CustomerId IS NULL

--
SELECT Customers.FirstName, Orders.CreatedAt, 
       Products.ProductName, Products.Manufacturer
FROM Orders 
JOIN Products ON Orders.ProductId = Products.Id AND Products.Price < 45000
LEFT JOIN Customers ON Orders.CustomerId = Customers.Id
ORDER BY Orders.CreatedAt

-- Cross Join
SELECT * FROM Orders CROSS JOIN Customers
-- При неявному перехресному з'єднанні можна опустити оператор CROSS JOIN і просто перерахувати всі таблиці:
SELECT * FROM Orders, Customers
-------------------------------
-- Угруповання у з'єднаннях
-- У виразах INNER/OUTER JOIN також можна використовувати групування. 
-- Наприклад, виведемо для кожного користувача кількість замовлень, які він зробив:

SELECT FirstName, COUNT(Orders.Id)
FROM Customers JOIN Orders 
ON Orders.CustomerId = Customers.Id
GROUP BY Customers.Id, Customers.FirstName;

--Критерієм угруповання виступають Id та ім'я покупця. Вираз SELECT вибирає ім'я покупця та кількість замовлень, 
--використовуючи стовпець Id із таблиці Orders.

--Так як це INNER JOIN, то в групах будуть лише покупці, які мають замовлення.

--Якщо необхідно вивести навіть тих покупців, які не мають замовлень, то застосовується OUTER JOIN

SELECT FirstName, COUNT(Orders.Id)
FROM Customers LEFT JOIN Orders 
ON Orders.CustomerId = Customers.Id
GROUP BY Customers.Id, Customers.FirstName;

-- Або виведемо товари із загальною сумою зроблених замовлень:
SELECT Products.ProductName, Products.Manufacturer, 
        SUM(Orders.ProductCount * Orders.Price) AS Units
FROM Products LEFT JOIN Orders
ON Orders.ProductId = Products.Id
GROUP BY Products.Id, Products.ProductName, Products.Manufacturer

------------
-- UNION 

--Оператор UNION подібно до inner join або outer join дозволяє з'єднати дві таблиці. 
--Але, на відміну від inner/outer join, об'єднання з'єднують не стовпці різних таблиць, а два однотипних набори в один. 

--SELECT_выражение1
--UNION [ALL] SELECT_выражение2
--[UNION [ALL] SELECT_выражениеN]

CREATE TABLE Customers
(
    Id INT IDENTITY PRIMARY KEY,
    FirstName NVARCHAR(20) NOT NULL,
    LastName NVARCHAR(20) NOT NULL,
    AccountSum MONEY
);
CREATE TABLE Employees
(
    Id INT IDENTITY PRIMARY KEY,
    FirstName NVARCHAR(20) NOT NULL,
    LastName NVARCHAR(20) NOT NULL,
);
 
INSERT INTO Customers VALUES
('Tom', 'Smith', 2000),
('Sam', 'Brown', 3000),
('Mark', 'Adams', 2500),
('Paul', 'Ins', 4200),
('John', 'Smith', 2800),
('Tim', 'Cook', 2800)
 
INSERT INTO Employees VALUES
('Homer', 'Simpson'),
('Tom', 'Smith'),
('Mark', 'Adams'),
('Nick', 'Svensson')

---
SELECT FirstName, LastName 
FROM Customers
UNION SELECT FirstName, LastName FROM Employees

--
SELECT FirstName + ' ' + LastName AS FullName
FROM Customers
UNION SELECT FirstName + ' ' + LastName AS EmployeeName 
FROM Employees
ORDER BY FullName DESC

--
SELECT FirstName, LastName, AccountSum
FROM Customers
UNION SELECT FirstName, LastName 
FROM Employees

--
SELECT FirstName, LastName
FROM Customers
UNION SELECT Id, LastName 
FROM Employees

--
SELECT FirstName, LastName
FROM Customers
UNION ALL SELECT FirstName, LastName 
FROM Employees

--
SELECT FirstName, LastName, AccountSum + AccountSum * 0.1 AS TotalSum 
FROM Customers WHERE AccountSum < 3000
UNION SELECT FirstName, LastName, AccountSum + AccountSum * 0.3 AS TotalSum 
FROM Customers WHERE AccountSum >= 3000

-----------------------
-- EXCEPT

-- Оператор EXCEPT дозволяє знайти різницю двох вибірок, тобто ті рядки, які є в першій вибірці, але яких немає в другій. 

--SELECT_выражение1
--EXCEPT SELECT_выражение2

SELECT FirstName, LastName
FROM Customers
EXCEPT SELECT FirstName, LastName 
FROM Employees

--
SELECT FirstName, LastName
FROM Employees
EXCEPT SELECT FirstName, LastName 
FROM Customers

--------------
-- INTERSECT

-- Оператор INTERSECT дозволяє знайти спільні рядки для двох вибірок, тобто оператор виконує операцію перетину множин.

--SELECT_выражение1
--INTERSECT SELECT_выражение2

SELECT FirstName, LastName
FROM Employees
INTERSECT SELECT FirstName, LastName 
FROM Customers
-------------------

-- Функції для роботи з рядками

--Для роботи з рядками у T-SQL можна застосовувати такі функції:

--LEN : повертає кількість символів у рядку. Як параметр у функцію передається рядок, для якого треба знайти довжину:

SELECT LEN('Apple')  -- 5
--LTRIM : видаляє початкові пробіли з рядка. Як параметр приймає рядок:

SELECT LTRIM('  Apple')
--RTRIM : видаляє кінцеві пропуски з рядка. Як параметр приймає рядок:

SELECT RTRIM(' Apple    ')
--CHARINDEX : повертає індекс, за яким знаходиться перше входження підрядка в рядку. Як перший параметр передається підрядок, а як другий - рядок, в якому треба вести пошук:

SELECT CHARINDEX('pl', 'Apple') -- 3
--PATINDEX : повертає індекс, яким знаходиться перше входження певного шаблону в рядку:

SELECT PATINDEX('%p_e%', 'Apple')   -- 3
--LEFT : вирізує з початку рядка певну кількість символів. Перший параметр функції – рядок, а другий – кількість символів, які треба вирізати спочатку рядки:

SELECT LEFT('Apple', 3) -- App
--RIGHT : вирізує з кінця рядка певну кількість символів. Перший параметр функції – рядок, а другий – кількість символів, які треба вирізати спочатку рядки:

SELECT RIGHT('Apple', 3)    -- ple
--SUBSTRING : вирізає з рядка підрядок певною довжиною, починаючи з певного індексу. Співаний параметр функції - рядок, другий - початковий індекс для вирізки, і третій параметр - кількість символів, що вирізуються:

SELECT SUBSTRING('Galaxy S8 Plus', 8, 2)    -- S8
--REPLACE : замінює один підрядок на інший в рамках рядка. Перший параметр функції - рядок, другий - підрядок, який треба замінити, а третій - підрядок, на який треба замінити:

SELECT REPLACE('Galaxy S8 Plus', 'S8 Plus', 'Note 8')   -- Galaxy Note 8
--REVERSE : перевертає рядок навпаки:

SELECT REVERSE('123456789') -- 987654321
--CONCAT : об'єднує два рядки в один. Як параметр приймає від 2-х і більше рядків, які треба з'єднати:

SELECT CONCAT('Tom', ' ', 'Smith')  -- Tom Smith
--LOWER : перекладає рядок у нижній регістр:

SELECT LOWER('Apple')   -- apple
--UPPER : перекладає рядок у верхній регістр

SELECT UPPER('Apple')   -- APPLE
--SPACE : повертає рядок, який містить певну кількість прогалин

--
CREATE TABLE Products
(
    Id INT IDENTITY PRIMARY KEY,
    ProductName NVARCHAR(30) NOT NULL,
    Manufacturer NVARCHAR(20) NOT NULL,
    ProductCount INT DEFAULT 0,
    Price MONEY NOT NULL
);

go

SELECT UPPER(LEFT(Manufacturer,2)) AS Abbreviation,
       CONCAT(ProductName, ' - ',  Manufacturer) AS FullProdName
FROM Products
ORDER BY Abbreviation

-----------------------
--Для роботи з числовими даними T-SQL надає низку функцій:

--ROUND : Заокруглює число. Як перший параметр передається число. Другий параметр вказує на довжину. Якщо довжина представляє позитивне число, воно вказує, до якої цифри після коми йде округлення. Якщо довжина представляє від'ємне число, воно вказує, до якої цифри з кінця числа до коми йде округлення

SELECT ROUND(1342.345, 2)   -- 1342.350
SELECT ROUND(1342.345, -2)  -- 1300.000
--ISNUMERIC : визначає, чи є значення числом. Як параметр функція приймає вираз. Якщо вираз є числом, функція повертає 1. Якщо не є, то повертається 0.

SELECT ISNUMERIC(1342.345)          -- 1
SELECT ISNUMERIC('1342.345')        -- 1
SELECT ISNUMERIC('SQL')         -- 0
SELECT ISNUMERIC('13-04-2017')  -- 0
--ABS : повертає абсолютне значення числа.

SELECT ABS(-123)    -- 123
--CEILING : повертає найменше ціле число, яке більше або дорівнює поточному значенню.

SELECT CEILING(-123.45)     -- -123
SELECT CEILING(123.45)      -- 124
--FLOOR : повертає найбільше ціле число, яке менше або дорівнює поточному значенню.

SELECT FLOOR(-123.45)       -- -124
SELECT FLOOR(123.45)        -- 123
--SQUARE : зводить число квадрат.

SELECT SQUARE(5)        -- 25
--SQRT : отримує квадратний корінь числа.

SELECT SQRT(225)        -- 15
--RAND : генерує випадкове число з точкою, що плаває, в діапазоні від 0 до 1.

SELECT RAND()       -- 0.707365088352935
SELECT RAND()       -- 0.173808327956812
--COS : повертає косинус кута, вираженого в радіанах

SELECT COS(1.0472)  -- 0.5 - 60 градусов
--SIN : повертає синус кута, вираженого в радіанах

SELECT SIN(1.5708)  -- 1 - 90 градусов
--TAN : повертає тангенс кута, вираженого в радіанах

SELECT TAN(0.7854)  -- 1 - 45 градусов

---
CREATE TABLE Products
(
    Id INT IDENTITY PRIMARY KEY,
    ProductName NVARCHAR(30) NOT NULL,
    Manufacturer NVARCHAR(20) NOT NULL,
    ProductCount INT DEFAULT 0,
    Price MONEY NOT NULL
);

--Округлимо добуток ціни товару на кількість цього товару:

SELECT ProductName, ROUND(Price * ProductCount, 2)
FROM Products

-----------------------------
-- Функції по роботі з датами та часом

--T-SQL надає ряд функцій для роботи з датами та часом:

--GETDATE : повертає поточну локальну дату та час на основі системного годинника у вигляді об'єкта datetime

SELECT GETDATE()    -- 2017-07-28 21:34:55.830
--GETUTCDATE : повертає поточну локальну дату та час за гринвічем (UTC/GMT) у вигляді об'єкта datetime

SELECT GETUTCDATE()     -- 2017-07-28 18:34:55.830
--SYSDATETIME : повертає поточну локальну дату та час на основі системного годинника, але відмінність від GETDATE полягає в тому, що дата та час повертаються у вигляді об'єкта datetime2

SELECT SYSDATETIME()        -- 2017-07-28 21:02:22.7446744
--SYSUTCDATETIME : повертає поточну локальну дату та час за гринвічем (UTC/GMT) у вигляді об'єкта datetime2

SELECT SYSUTCDATETIME()     -- 2017-07-28 18:20:27.5202777
--SYSDATETIMEOFFSET : повертає об'єкт datetimeoffset(7), який містить дату та час щодо GMT

SELECT SYSDATETIMEOFFSET()      -- 2017-07-28 21:02:22.7446744 +03:00
--DAY : повертає день дати, який передається як параметр

SELECT DAY(GETDATE())       -- 28
--MONTH : повертає місяць дати

SELECT MONTH(GETDATE())     -- 7
--YEAR : повертає рік з дати

SELECT YEAR(GETDATE())      -- 2017
--DATENAME : повертає частину дати у вигляді рядка. Параметр вибору частини дати передається як перший параметр, 
--а сама дата передається як другий параметр:

SELECT DATENAME(month, GETDATE())       -- July
--Для визначення частини дати можна використовувати такі параметри (у дужках вказано їх скорочені версії):

--year (yy, yyyy): рік

--quarter (qq, q): околиці

--month (mm, m): місяць

--dayofyear (dy, y): день року

--day (dd, d): день місяця

--week (wk, ww): неділя

--weekday (dw): день тижня

--hour (hh): час

--minute (mi, n): хвилини

--second (ss, s): другий

--millisecond (ms): мілісекунди

--microsecond (mcs): мікросекунда

--nanosecond (ns): наносекунда

--tzoffset (tz): змішання у хвилинах щодо грінвіча (для об'єкта datetimeoffset)

--DATEPART : повертає частину дати у вигляді числа. Параметр вибору частини дати передається як перший параметр (використовуються ті ж параметри, що і для DATENAME), а сама дата передається як другий параметр:

SELECT DATEPART(month, GETDATE())       -- 7
--DATEADD : повертає дату, яка є результатом додавання числа до певного компонента дати. Першим параметром є компонент дати, описаний вище для функції DATENAME. Другий параметр - кількість, що додається. Третій параметр - сама дата, до якої треба зробити додаток:

SELECT DATEADD(month, 2, '2017-7-28')       -- 2017-09-28 00:00:00.000
SELECT DATEADD(day, 5, '2017-7-28')     -- 2017-08-02 00:00:00.000
SELECT DATEADD(day, -5, '2017-7-28')        -- 2017-07-23 00:00:00.000
--Якщо кількість, що додається, представляє негативне число, то фактично відбувається зменшення дати.

--DATEDIFF : повертає різницю між двома датами. Перший параметр – компонент дати, який вказує, у яких одиницях варто вимірювати різницю. Другий та третій параметри - порівнювані дати:

SELECT DATEDIFF(year, '2017-7-28', '2018-9-28')     -- разница 1 год
SELECT DATEDIFF(month, '2017-7-28', '2018-9-28')    -- разница 14 месяцев
SELECT DATEDIFF(day, '2017-7-28', '2018-9-28')      -- разница 427 дней
--TODATETIMEOFFSET : повертає значення datetimeoffset, яке є результатом складання тимчасового зміщення з об'єктом datetime2

SELECT TODATETIMEOFFSET('2017-7-28 01:10:22', '+03:00')
--SWITCHOFFSET : повертає значення datetimeoffset, яке є результатом складання тимчасового зміщення з іншим об'єктом datetimeoffset

SELECT SWITCHOFFSET(SYSDATETIMEOFFSET(), '+02:30')
--EOMONTH : повертає дату останнього дня для місяця, який використовується в переданій даті.

SELECT EOMONTH('2017-02-05')    -- 2017-02-28
SELECT EOMONTH('2017-02-05', 3) -- 2017-05-31
--Як необов'язковий другий параметр можна передавати кількість місяців, які необхідно додати до дати. 
--Тоді останній день місяця обчислюватиметься для нової дати.

--DATEFROMPARTS : за роком, місяцем та днем ​​створює дату

SELECT DATEFROMPARTS(2017, 7, 28)       -- 2017-07-28
--ISDATE : перевіряє, чи є вираз датою. Якщо є, то повертає 1 інакше повертає 0.

SELECT ISDATE('2017-07-28')     -- 1
SELECT ISDATE('2017-28-07')     -- 0
SELECT ISDATE('28-07-2017')     -- 0
SELECT ISDATE('SQL')            -- 0

---
CREATE TABLE Orders
(
    Id INT IDENTITY PRIMARY KEY,
    ProductId INT NOT NULL,
    CustomerId INT NOT NULL,
    CreatedAt DATE NOT NULL DEFAULT GETDATE(),
    ProductCount INT DEFAULT 1,
    Price MONEY NOT NULL
);
-- Вираз DEFAULT GETDATE() вказує, що якщо при додаванні даних не передається дата,
-- вона автоматично обчислюється за допомогою функції GETDATE().

-- Інший приклад – знайдемо замовлення, які були зроблені 16 днів тому:

SELECT * FROM Orders
WHERE DATEDIFF(day, CreatedAt, GETDATE()) = 16

-------------------------------
-- Перетворення даних

--Коли ми надаємо значення одного типу стовпцю, який зберігає дані іншого типу, або виконуємо операції, які залучають дані різних типів, 
--SQL Server намагається виконати перетворення і привести значення до потрібного типу. 
--Але не всі перетворення SQL Server може виконати автоматично. 
--SQL Server може виконувати неявні перетворення від типу з меншим пріоритетом до типу з більшим пріоритетом. 
--Таблиця пріоритетів (що вище, тим більший пріоритет):

--datetime
--smalldatetime
--float
--real
--decimal
--money
--smallmoney
--int
--smallint
--tinyint
--bit
--nvarchar
--nchar
--varchar
--char

--Тобто SQL Server автоматично може перетворити число 100.0 (float) на дату та час (datetime).

--У тих випадках, коли необхідно виконати перетворення від типів із вищим пріоритетом до типів із нижчим пріоритетом,
--то треба виконувати явне приведення типів. Для цього в T-SQL визначено дві функції: CONVERT та CAST .

-- CAST(выражение AS тип_данных)

--
SELECT Id, CAST(CreatedAt AS nvarchar) + '; total: ' + CAST(Price * ProductCount AS nvarchar) 
FROM Orders

-- Більшість перетворень охоплює функція CAST. Якщо ж необхідне додаткове форматування, то можна використовувати функцію CONVERT .
-- Вона має таку форму:

-- CONVERT(тип_данных, выражение [, стиль])

--Третій необов'язковий параметр визначає стиль форматування даних. 
--Цей параметр є числове значення, яке для різних типів даних має різну інтерпретацію. 
--Наприклад, деякі значення для форматування дат та часу:

--0 або 100- формат дати "Mon dd yyyy hh:miAM/PM" (за замовчуванням)

--1 або 101- формат дати "мм/дд/рррр"

--3 або 103- формат дати "дд/мм/рррр"

--7 або 107- формат дати "Mon dd, yyyy hh:miAM/PM"

--8 або 108- формат дати "гг:мі:сс"

--10 або 110- формат дати "мм-дд-рррр"

--14 або 114- формат дати "hh:mi:ss:mmmm" (24-годинний формат часу)

--Деякі значення для форматування даних типу money у рядок:

--0- у дробовій частині числа залишаються лише дві цифри (за замовчуванням)

--1- у дробовій частині числа залишаються тільки дві цифри, а для поділу розрядів застосовується кома

--2- у дробовій частині числа залишаються лише чотири цифри

-- Наприклад, виведемо дату та вартість замовлень із форматуванням:

SELECT CONVERT(nvarchar, CreatedAt, 3), 
       CONVERT(nvarchar, Price * ProductCount, 1) 
FROM Orders

-- TRY_CONVERT

-- У разі використання функцій CAST та CONVERT SQL Server викидає виняток, якщо дані не можуть призвести до певного типу. Наприклад:
	
SELECT CONVERT(int, 'sql')

-- Щоб уникнути генерації виключення, можна використовувати функцію TRY_CONVERT . 
-- Її використання аналогічно функції CONVERT за винятком, що й вираз не вдається перетворити до потрібного типу, то функція повертає NULL:

SELECT TRY_CONVERT(int, 'sql')      -- NULL
SELECT TRY_CONVERT(int, '22')       -- 22

--Додаткові функції
--Крім CAST, CONVERT, TRY_CONVERT є ще ряд функцій, які можуть використовуватися для перетворення на ряд типів:

--STR(float [, length [,decimal]]) : перетворює число в рядок. 
--Другий параметр вказує на довжину рядка, а третій - скільки знаків у дрібній частині числа треба залишати

--CHAR(int) : перетворює числовий код ASCII на символ. 
--Нерідко використовується для тих ситуацій, коли потрібний символ, який не можна ввести з клавіатури

--ASCII(char) : перетворює символ на числовий код ASCII

--NCHAR(int) : перетворює числовий код UNICODE на символ

--UNICODE(char) : перетворює символ на числовий код UNICODE

SELECT STR(123.4567, 6,2)   -- 123.46
SELECT CHAR(219)            --  Ы
SELECT ASCII('Ы')           -- 219
SELECT NCHAR(1067)          -- Ы
SELECT UNICODE('Ы')     -- 1067

------------------------------------
-- Функції NEWID, ISNULL та COALESCE

-- Для створення об'єкта UNIQUEIDENTIFIER, тобто деякого унікального значення, використовується функція NEWID() . 
-- Наприклад, ми можемо визначити для стовпця первинного ключа тип UNIQUEIDENTIFIER і за умовчанням надавати йому значення функції NEWID:

CREATE TABLE Clients
(
    Id UNIQUEIDENTIFIER PRIMARY KEY DEFAULT NEWID(),
    FirstName NVARCHAR(20) NOT NULL,
    LastName NVARCHAR(20) NOT NULL,
    Phone NVARCHAR(20) NULL,
    Email NVARCHAR(20) NULL
)
 
INSERT INTO Clients (FirstName, LastName, Phone, Email)
VALUES ('Tom', 'Smith', '+36436734', NULL),
('Bob', 'Simpson', NULL, NULL)

-- Функція ISNULL перевіряє значення певного виразу. Якщо воно дорівнює NULL, то функція повертає значення, яке передається як другий параметр:
-- ISNULL(выражение, значение)

SELECT FirstName, LastName,
        ISNULL(Phone, 'не определено') AS Phone,
        ISNULL(Email, 'неизвестно') AS Email
FROM Clients

-- Функція COALESCE приймає список значень та повертає перше з них, яке не дорівнює NULL:
-- COALESCE(выражение_1, выражение_2, выражение_N)

-- Наприклад, виберемо з таблиці Clients користувачів і в контактах у них визначимо телефон, або електронну адресу, якщо вони не рівні NULL:
SELECT FirstName, LastName,
        COALESCE(Phone, Email, 'не определено') AS Contacts
FROM Clients

-- Тобто в цьому випадку телефон повертається, якщо він визначений. Якщо його не визначено, то повертається електронна адреса.
-- Якщо й електронна адреса не визначена, то повертається рядок "не визначено".

------------------------------------------------
-- Функція CASE перевіряє значення деякого виразу, і залежно від результату перевірки може повертати той чи інший результат.

--CASE выражение
--    WHEN значение_1 THEN результат_1
--    WHEN значение_2 THEN результат_2
--    .................................
--    WHEN значение_N THEN результат_N
--    [ELSE альтернативный_результат]
--END

---
CREATE TABLE Products
(
    Id INT IDENTITY PRIMARY KEY,
    ProductName NVARCHAR(30) NOT NULL,
    Manufacturer NVARCHAR(20) NOT NULL,
    ProductCount INT DEFAULT 0,
    Price MONEY NOT NULL
);

--
SELECT ProductName, Manufacturer,
    CASE ProductCount
        WHEN 1 THEN 'Товар заканчивается'
        WHEN 2 THEN 'Мало товара'
        WHEN 3 THEN 'Есть в наличии'
        ELSE 'Много товара'
    END AS EvaluateCount
FROM Products

-- Тут значення стовпця ProductCount послідовно порівнюється зі значеннями після операторів WHEN. 
--Залежно від значення стовпця ProductCount функція CASE повертатиме один із рядків, що йде після відповідного оператора THEN. 
--Для результату, що повертається, визначений стовпець EvaluateCount

-- Також функція CASE може набувати ще однієї форми:

--CASE
--    WHEN выражение_1 THEN результат_1
--    WHEN выражение_2 THEN результат_2
--    .................................
--    WHEN выражение_N THEN результат_N
--    [ELSE альтернативный_результат]
--END

--
SELECT ProductName, Manufacturer,
    CASE
        WHEN Price > 50000 THEN 'Категория A'
        WHEN Price BETWEEN 40000 AND 50000 THEN 'Категория B'
        WHEN Price BETWEEN 30000 AND 40000 THEN 'Категория C'
        ELSE 'Категория D'
    END AS Category
FROM Products

-- Фактично все те саме, що і в попередньому прикладі, тільки після CASE не вказується порівнюване значення. 
--А самі порівняння стоять після оператора WHEN. 
--І якщо вираз після оператора WHEN буде істинним, то повертається значення, яке йде після відповідного оператора THEN.

-- Функція IIF залежно від результату умовного виразу повертає одне із двох значень. Загальна форма функції виглядає так:
-- IIF(условие, значение_1, значение_2)

-- Якщо умова функції IIF істинно то повертається значення_1, якщо помилково, то повертається значення_2. Наприклад:
SELECT ProductName, Manufacturer,
    IIF(ProductCount>3, 'Много товара', 'Мало товара')
FROM Products
------------------------------------------------------------