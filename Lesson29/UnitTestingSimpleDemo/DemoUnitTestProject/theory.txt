Що таке модульне тестування?

Модульне тестування — це процес перевірки правильності окремих одиниць коду, як правило, методів або функцій, ізольовано від решти системи. 
Це гарантує, що кожен блок працює належним чином, і допомагає виявляти потенційні помилки чи проблеми на ранніх стадіях процесу розробки.

Модульні тести є автоматизованими, самодостатніми та зосередженими на конкретних аспектах блоку. 
Вони повинні бути простими для розуміння, підтримки та виконання, забезпечуючи міцну основу для будь-якого розробника, який хоче забезпечити якість свого коду.


Важливість модульного тестування в розробці програмного забезпечення
Модульне тестування є важливою практикою в сучасній розробці програмного забезпечення. Його важливість неможливо переоцінити, оскільки він:

Забезпечує функціональність: перевіряє, чи кожна одиниця коду працює належним чином, уникаючи помилок та інших проблем.
Покращує ремонтопридатність: добре написані тести діють як сітка безпеки, дозволяючи розробникам впевнено рефакторювати або змінювати код.
Покращує якість коду: він заохочує передові практики, такі як принципи SOLID, і допомагає розробникам краще писати код, який можна перевірити.
Прискорює розробку: раннє та часте тестування дозволяє розробникам швидше виявляти та виправляти проблеми, зменшуючи загальний час, витрачений на налагодження.
Сприяє співпраці. Спільні пакети тестів дають розробникам загальне розуміння коду та забезпечують плавну співпрацю та кращу комунікацію.


C# та .NET Unit Test Landscape: Тестування фреймворків та інструментів
Є кілька тестових фреймворків і інструментів, доступних для модульного тестування в C# і .NET, але найпопулярніші з них:

xUnit: сучасна, розширювана платформа тестування, яка зосереджена на простоті та легкості використання. 
Його часто вважають фактичним вибором для модульного тестування в .NET Core.

NUnit: широко використовувана добре налагоджена платформа тестування з багатим набором функцій і розгалуженою екосистемою плагінів. 
Він має довгу історію, і його використовують багато застарілих проектів .NET.

MSTest: стандартна платформа тестування, яка надається пакетом Microsoft Visual Studio, 
забезпечує тісну інтеграцію з Visual Studio та підтримується підтримкою Microsoft.

Moq: потужна бібліотека імітацій, спеціально розроблена для .NET, що дозволяє розробникам створювати 
імітаційні об’єкти для ізольованого тестування одиниць, які взаємодіють із зовнішніми залежностями

Кожен фреймворк має свої сильні та слабкі сторони, але в цій статті ми зосередимося на xUnit і Moq, 
популярних варіантах серед розробників C# для модульного тестування.


Чому варто вибрати xUnit замість інших інфраструктур тестування?
xUnit став кращим вибором у спільноті .NET з кількох причин:

Сучасність: розроблено спеціально для .NET Core, додаючи сучасний підхід і нові функції.
Простота: xUnit наголошує на простоті, що полегшує вивчення та використання навіть для розробників, які не знайомі з модульним тестуванням.
Розширюваність: xUnit надає багато можливостей розширення, таких як його атрибути, твердження та угоди, що дозволяє розробникам адаптувати його до своїх потреб.
Сильна підтримка спільноти: Завдяки широкому застосуванню в спільноті .NET xUnit має велику кількість ресурсів, документації та відповідей на поширені запитання.
Інтеграція: він може похвалитися інтеграцією з такими популярними інструментами, як Visual Studio, VSCode, ReSharper і .NET CLI, що спрощує тестування.


Атрибути xUnit Test, умовні позначення та процес виконання
xUnit використовує різноманітні атрибути та умовності у своєму потоці виконання:

Факт: атрибут [Fact] вказує на те, що метод є тестовим прикладом. Метод не повинен мати ані типу повернення, ані вхідних параметрів.
Теорія. Атрибут [Теорія] вказує на керований даними метод тестування, що дозволяє кілька вхідних даних, кожен із яких призводить до окремого виконання тесту.
InlineData: атрибут [InlineData] надає вбудовані дані для тестів [Theory], спрощуючи керування даними тестів.
MemberData: [MemberData] дозволяє обмінюватися даними між тестовими методами, вказуючи член, з якого потрібно отримати тестові дані.
Крім того, xUnit має додаткову конвенцію для керування порядком виконання тесту, яку можна налаштувати для керування потоком виконання тесту відповідно до конкретних вимог.


Анатомія добре структурованого тесту: організувати, діяти, підтвердити (Arrange, Act, Assert)
Хороший юніт-тест відповідає шаблону «Упорядкувати, діяти, стверджувати», що робить код простим, легким для розуміння та придатним для обслуговування. 
Щоб пояснити цю закономірність, розберемо її:

Упорядкувати (Arrange): налаштувати тестове середовище та створити екземпляр системи, що тестується, або її залежностей. 
На практиці це може означати створення макетів об’єктів, налаштування обробників винятків або ініціалізацію стану.

Дійте (Act): викликайте цільовий метод за допомогою підготовленого середовища.

Стверджуйте (Assert): перевірте, чи відповідає очікуваний результат фактичному результату. 
Якщо ні, тест проходить невдало. Намагайтеся, щоб кількість ваших тверджень була рівною одному на тест.

Цей шаблон допомагає переконатися, що тести логічно організовані та доступні, сприяючи кращій зручності тестування.


Налаштування тесту інкапсуляції та демонтаж (Test Setup and Teardown)

У багатьох сценаріях тестування нам потрібно виконати налаштування або очищення коду до або після виконання тесту. 
xUnit підтримує інкапсуляцію налаштування тесту та код демонтажу за допомогою:

Конструктор і: в xUnit конструктор тестового класу використовується для налаштування, а реалізація інтерфейсу IDisposable використовується для демонтажу. 
Це найпоширеніший і рекомендований підхід.

public class MyTestFixture : IDisposable
{
    public MyTestFixture()
    {
        // Test setup code here
    }

    public void Dispose()
    {
        // Test teardown code here
    }
}

IAsyncLifetime: для асинхронного налаштування та демонтажу коду xUnit надає інтерфейс IAsyncLifetime, який має методи InitializeAsync і DisposeAsync.

public class MyTestFixture : IAsyncLifetime
{
    public async Task InitializeAsync()
    {
        // Async test setup code here
    }

    public async Task DisposeAsync()
    {
        // Async test teardown code here
    }
}


Рекомендації щодо модульного тестування C#: іменування, організація та деталізація


Щоб підтримувати чистий і придатний для обслуговування тестовий код, важливо звернути увагу на організацію та правила іменування. 
Деякі найкращі практики включають:

Назви: дайте своїм тестовим методам описові назви, які передають їхнє призначення. 
Використання такої угоди, як MethodName_Scenario_ExpectedBehavior, допомагає швидко зрозуміти мету тесту.
Організація: групуйте пов’язані тести в одному класі чи просторі імен, що полегшує пошук відповідних тестів.
Деталізація: прагніть перевірити одну поведінку на тестовий приклад. Менші тести зменшують зусилля з налагодження, якщо тест не вдається.
Розбірливість: пишіть чіткі та прості для розуміння тести, щоб розробникам було легко зрозуміти наміри та очікування від тесту.


Включення розробки, керованої тестуванням (TDD) у ваш робочий процес
Test-Driven Development (TDD) — це потужна методологія розробки, яка спочатку полягає в написанні тестів, а потім упровадженні. 
Це циклічний процес:

Напишіть невдалий тест
Реалізуйте функціональність для проходження тесту
Рефакторинг коду, зберігаючи тест зеленим
TDD сприяє підвищенню якості коду, зручності обслуговування та загальної ефективності розробки, 
оскільки основна увага приділяється написанню простого, зрозумілого та перевіреного коду з самого початку.


Розширені методи xUnit для надійних тестів


Використання тестів, керованих даними, за допомогою InlineData та MemberData
Атрибут [Theory] xUnit дозволяє створювати тести на основі даних, використовуючи [InlineData] або [MemberData] для надання вхідних значень:

InlineData: надає вбудовані значення даних безпосередньо в атрибуті методу тестування.

[Theory]
[InlineData(1, 2, 3)]
[InlineData(-1, -2, -3)]
public void Add_TwoNumbers_ReturnsSum(int a, int b, int expectedResult)
{
    // Test implementation
}

MemberData: визначає член (властивість або метод), який повертає перелік тестових даних, який повинен повертати масив об’єктів для кожного тестового випадку.

public static IEnumerable<object[]> TestData
{
    get
    {
        yield return new object[] { 1, 2, 3 };
        yield return new object[] { -1, -2, -3 };
    }
}

[Theory]
[MemberData(nameof(TestData))]
public void Add_TwoNumbers_ReturnsSum(int a, int b, int expectedResult)
{
    // Test implementation
}


Спільне використання тестових контекстів за допомогою фікстур класу та колекції
У xUnit спільний доступ до тестового контексту досягається за допомогою фікстур, 
що допомагає уникнути дублювання коду та забезпечує послідовне налаштування/демонтаж.

Class Fixture: спільний доступ до одного екземпляра контексту для всіх тестів у класі. 
Щоб використовувати фікстуру класу, створіть клас, що реалізує інтерфейс IClassFixture<T>, де T — тип контексту.

public class MyTestFixture : IClassFixture<MyContext>
{
    // Test implementation
}

Пристосування колекції: надає спільний доступ до екземпляра контексту для кількох тестових класів, що корисно для ресурсомістких установок. 
Створіть клас визначення колекції, що реалізує інтерфейс ICollectionFixture<T>, а потім застосуйте атрибут [CollectionDefinition].

[CollectionDefinition("MyCollection")]
public class MyCollection : ICollectionFixture<MyContext>
{
}

[Collection("MyCollection")]
public class MyTest1
{
    // Test implementation
}

[Collection("MyCollection")]
public class MyTest2
{
    // Test implementation
}


Пропуск тестів і умовне виконання тестів у xUnit
Іноді ми можемо захотіти пропустити тести або виконати їх умовно, виходячи з конкретних обставин. xUnit надає опції для полегшення цього:

Пропуск тестів: використовуйте параметр Пропустити в атрибутах [Факт] або [Теорія], щоб пропустити тест.

[Fact(Skip = "Skipping this test due to ...")]
public void MySkippedTest()
{
    // Test implementation
}

Умовне виконання тесту: атрибути [ConditionalFact] і [ConditionalTheory] дозволяють умовно виконувати тести, керовані логічним значенням, 
яке можна отримати за допомогою спеціального методу або властивості.

[ConditionalFact(nameof(IsFeatureEnabled))]
public void MyConditionalTest()
{
    // Test implementation
}

private static bool IsFeatureEnabled()
{
    // Return true if feature is enabled
}

Налаштування результату тестування: реєстратори та звіти xUnit
У деяких сценаріях ви можете налаштувати тестовий вихід для створення звітів або журналів у різних форматах. 
xUnit підтримує це через систему реєстраторів і репортерів:

Реєстратори: реалізуйте інтерфейс ITestOutputHelper, щоб перенаправляти вихідні дані тесту в спеціальні місця або додавати додаткову інформацію.


public class MyTests
  {
      private readonly ITestOutputHelper _output;

      public MyTests(ITestOutputHelper output)
      {
          _output = output;
      }

      [Fact]
      public void TestWithCustomOutput()
      {
          _output.WriteLine("Custom log message");
          // Test implementation
      }
  }

  Репортери: користувальницькі звіти можна створювати, реалізувавши інтерфейс IMessageSinkWithTypes, 
  що забезпечує більш детальний контроль над результатами тестування та форматуванням.


  public class MyCustomReporter : IMessageSinkWithTypes
  {
      public bool OnMessageWithTypes(IMessageSinkMessage message, HashSet<string> messageTypes)
      {
          // Custom test report logic here
      }
  }


]Поради щодо роботи з нестабільними та недетермінованими тестами
Нестабільні тести можуть спричинити головний біль і втрату часу,
оскільки результати їх проходження/непроходження можуть змінюватися залежно від зовнішніх факторів або часу. 
Деякі поради щодо роботи з недетермінованими тестами включають:

Mocking: використовуйте Mocking фреймворки, такі як Moq, щоб замінити зовнішні залежності, які можуть спричинити нестабільність.
Тайм-аути (Timeouts): використовуйте тайм-аути, щоб перевірити, що тести не виконуються нескінченно через несправні механізми синхронізації або великі затримки.
Стабільність тесту (Test stability): зробіть ваші тести стійкими до незначних змін у системі, забезпечуючи узгодженість, одночасно перевіряючи правильність.
Повторна спроба (Retry): реалізуйте логіку повторної спроби для тестів, які періодично виявляються невдалими через тимчасові проблеми.


Вступ до Mocking і Moq для модульних тестів C#

Mocking — це практика створення «фальшивих» реалізацій об’єктів або залежностей, з якими взаємодіє система, що тестується. 
Це дозволяє розробникам ізолювати свої тести від фактичної реалізації, забезпечуючи покращений контроль, стабільність та ізоляцію. 
Переваги глузування включають:

Ізоляція тесту: імітації дозволяють повністю контролювати поведінку тесту та уникати побічних ефектів, викликаних реальними реалізаціями.
Більша гнучкість: за допомогою імітацій тестування стає більш гнучким завдяки ввімкненню граничних випадків або виняткових сценаріїв, 
які може бути важко відтворити за допомогою фактичних залежностей.
Зменшена складність: імітації дозволяють зосередитися на поведінці системи, що тестується, замість того, щоб мати справу зі складнощами реальних залежностей.
Швидкість: мокінг може значно пришвидшити виконання тесту за рахунок зменшення ресурсомістких операцій або взаємодії з мережею.


Moq: потужна та популярна бібліотека Mocking для розробників .NET
Moq — це популярна та потужна бібліотека імітацій .NET, яка надає простий та інтуїтивно зрозумілий API для створення і керування макетами об’єктів. 
Ключові особливості Moq:

Строга типізація: Moq використовує жорстку типізацію C#, забезпечуючи перевірку під час компіляції викликів фіктивних методів і поведінки.
Експресивний API: API Moq розроблений, щоб бути виразним і простим у використанні, 
що дозволяє розробникам визначати очікування та поведінку за допомогою мінімального коду.
запити: Moq підтримує запити LINQ, що спрощує визначення складної фіктивної поведінки та очікувань.
Інтеграція: Moq бездоганно працює з популярними фреймворками тестування, такими як xUnit, що полегшує створення надійних модульних тестів,
які можна підтримувати.


Щоб створити макет об’єкта за допомогою Moq, створіть екземпляр об’єкта Mock<T>, де T — це інтерфейс або клас, який імітується. 

Розглянемо наступний приклад з інтерфейсом IOrderService:

public interface IOrderService
{
    bool PlaceOrder(Order order);
}

Щоб створити макет об’єкта цього інтерфейсу, використовуйте такий код:

var mockOrderService = new Mock<IOrderService>();

Moq дозволяє вам визначити очікування та відповіді на ваші методи. Давайте розглянемо кілька поширених сценаріїв:


Returns: To specify a return value for a mocked method, use the Returns method:

mockOrderService.Setup(x => x.PlaceOrder(It.IsAny<Order>())).Returns(true);

Throws: To throw an exception when the mocked method is called, use the Throws method:

mockOrderService.Setup(x => x.PlaceOrder(It.IsAny<Order>())).Throws(new InvalidOperationException());

Callbacks: If you wish to execute specific code when a mocked method is called, use the Callback method:
  mockOrderService.Setup(x => x.PlaceOrder(It.IsAny<Order>()))
      .Callback<Order>(order => Console.WriteLine($"Order placed: {order.Id}"))
      .Returns(true);


Ще одна потужна функція Moq — це можливість перевірити взаємодію між системою, що тестується, і імітованими залежностями. 
Для цього скористайтеся методом перевірки:


mockOrderService.Verify(x => x.PlaceOrder(It.IsAny<Order>()), Times.Once);

Вихід за межі основ: зворотні виклики Moq, послідовності та виклик подій


Callbacks: As already mentioned, you can use Callback to execute specific code when a mock method is called. 
You can even capture method arguments for further validation:

  mockOrderService.Setup(x => x.PlaceOrder(It.IsAny<Order>()))
      .Callback<Order>(order => Assert.NotNull(order))
      .Returns(true);

Sequences: If a mocked method gets called multiple times, you can set up a sequence of responses or actions using the Sequence extension:

  mockOrderService.SetupSequence(x => x.PlaceOrder(It.IsAny<Order>()))
      .Returns(true)
      .Throws(new InvalidOperationException())
      .Returns(false);

Event Raising: Moq allows you to mock events and raise them from the mocked object:

  public interface IOrderNotifier
  {
      event EventHandler<OrderEventArgs> OrderPlaced;
  }

  var mockOrderNotifier = new Mock<IOrderNotifier>();
  // Raise the event
  mockOrderNotifier.Raise(x => x.OrderPlaced += null, new OrderEventArgs { Order = myOrder });


Інтеграція Moq і xUnit: випадки використання та проблеми
Інтеграція Moq з xUnit проста, оскільки вони добре працюють разом. Обидві бібліотеки підкреслюють простоту та зручність використання. 
Однак існують потенційні підводні камені, наприклад:

Тривалість життя тестових приладів: використовуючи спільні тестові прилади з Moq, майте на увазі, що час життя приладів впливає на стан ваших макетів об’єктів. 
Може знадобитися їх скидання або переналаштування.
Async/: якщо ваші тести включають асинхронні методи, обов’язково налаштуйте та перевірте відповідну поведінку макетних об’єктів.


Покращення модульних тестів за допомогою DI та найкращих практик
Тепер, коли ми ближче познайомилися з Moq, давайте дослідимо найкращі методи поєднання ін’єкції залежностей (DI) і мокінгу в наших тестах.

Впровадження залежностей для більшої гнучкості тестування
Впровадження залежностей (DI) — це шаблон проектування, який сприяє більшій гнучкості тестування. 
Впроваджуючи залежності як параметри конструктора або методу, а не безпосередньо створюючи їх, ми досягаємо:

Легше знущання: макетні об’єкти можна вставляти легше, що призводить до кращої ізоляції тесту.
Зменшений зв’язок: залежності виражені явно, що полегшує розуміння та підтримку коду.
Намагайтеся застосовувати DI скрізь, де це можливо, особливо під час роботи із зовнішніми залежностями, що дозволить вам працювати з Moq ефективніше.


Коли використовувати підробки, підробки та підробки у своїх тестах
Маючи справу із залежностями у своїх тестах, важливо розуміти, коли використовувати кожен тип:

Макети (Mocks): використовуйте макети, коли вам потрібно перевірити взаємодію або поведінку між тестованою системою та її залежностями. 
Корисно для підтвердження того, що конкретні методи були викликані з певними параметрами або певну кількість разів.

Заглушки (Stubs): використовуйте заглушки, коли вам потрібно надати фіксовані відповіді або дані із залежності, не підтверджуючи поведінку. 
Вони чудово підходять для надання вхідних даних і імітації переходів між станами.

Підробки (Fakes): підробки — це легкі реалізації залежностей у пам’яті, які відтворюють їх основну поведінку. 
Використовуйте їх, коли вам потрібен більший контроль над поведінкою або станом залежності, а також коли висміювання чи заглушення недостатньо.


Встановлення балансу: Ефективне імітаційне використання для супроводжуваних тестів
Надмірне використання макетів може призвести до крихких тестів, які легко ламаються та їх важко підтримувати. 
Важливо знайти баланс між глузуванням та іншими методами, як-от заглушка чи підробка. Ключові поради включають:

Don’t over-mock: Only mock лише над необхідними залежностями та уникайте знущань над усім.
Імітація лише частин залежності: іноді ви можете імітувати частини залежності, а не весь об’єкт.
Простота є ключовою: оцініть, чи справді потрібен макет. Використання простіших альтернатив, таких як заглушки або підробки, може спростити ваші тести.


Складання модульних тестів із фабриками та будівельниками
Щоб ще більше підвищити ремонтопридатність ваших тестів, використовуйте фабрики та розробники для створення макетів об’єктів, тестових даних або екземплярів вашої тестованої системи:

Фабрики: створюйте фабричні методи або класи, які створюють екземпляри або налаштовують загальні об’єкти, які використовуються у вашому наборі тестів. 
Це інкапсулює створення об’єктів і зменшує дублювання коду.
Конструктори: використовуйте шаблон конструктора для створення складних об’єктів, дозволяючи поступове налаштування властивостей або конфігурації.
Це призводить до більш читабельного та гнучкого тестового коду.


Вимірювання та покращення якості тесту за допомогою показників
Нарешті, давайте обговоримо, як виміряти якість тесту та внести покращення за допомогою таких показників, як охоплення коду, 
показники якості тесту та обробка граничних випадків.

Важливість покриття коду в модульних тестах C#
Покриття коду є цінним показником, який допомагає зрозуміти, наскільки добре ваші тести вправляються з робочим кодом. 
Хоча він не дає повного уявлення про якість тестування, він пропонує зрозуміти потенційні прогалини у вашому наборі тестів.

Прагніть до розумного, залежно від контексту рівня охоплення коду. Прагнення до 100% покриття не завжди практично чи ефективно. 
Натомість визначте, які частини вашого коду вимагають більш ретельного тестування, і переконайтеся, що шляхи критичного коду добре перевірені.


Використання Visual Studio та .NET CLI для аналізу покриття коду
Visual Studio та .NET CLI підтримують аналіз покриття коду, що дозволяє легко вимірювати покриття ваших тестів:

Visual Studio: версія Visual Studio Enterprise забезпечує вбудовану підтримку для аналізу покриття коду, має простий у використанні інтерфейс
і візуалізацію результатів. Ви також можете використовувати такі розширення, як ReSharper або dotCover, 
для аналізу покриття коду в інших випусках Visual Studio.
.NET CLI: Ви можете використовувати команду dotnet test для створення звітів про покриття коду в різних форматах (Cobertura, OpenCover тощо),
встановивши інструмент покриття, наприклад coverlet, і проаналізувавши результати за допомогою зовнішнього інструменту, наприклад ReportGenerator.
За межами покриття коду: показники якості тесту та евристика
Хоча покриття коду є корисним, важливо вимірювати інші аспекти якості тесту, зокрема:

Ефективність тестування: оцініть, наскільки добре ваші тести виявляють фактичні проблеми у вашому коді. 
Високоякісні тести краще виявляють дефекти та мінімізують помилкові негативні чи позитивні результати.
Простота обслуговування: оцініть, наскільки ваші тести легко зрозуміти, змінити та розширити. 
Високоякісні тести сприяють ремонтопридатності, знижуючи витрати на розробку з часом.
Час виконання тесту: відстежуйте час, потрібний для виконання тестів. 
Повільні тести можуть перешкоджати циклам розробки та відгуків, знижуючи загальну продуктивність.
Враховуйте ці фактори, коли оцінюєте якість свого набору тестів і вдосконалюєте його.


Обробка крайових і кутових випадків: стратегії всебічного тестування
Нарешті, під час розробки тестів важливо враховувати крайові та кутові випадки. 
Ці сценарії можуть призвести до неочікуваної поведінки або дефектів, тому їх слід ретельно перевірити, щоб забезпечити стабільність системи. 
Деякі стратегії обробки граничних випадків включають:

Аналіз граничних значень: Перевірте вхідні дані або умови на межі прийнятних діапазонів. 
Ці випадки часто виявляють проблеми з крайовими умовами або перевірками обмежень.
Розподіл класів еквівалентності: розділіть вхідні дані на групи або класи, які, як очікується,
будуть поводитися подібно, перевіряючи кожну групу за репрезентативними значеннями. Це може допомогти вам виявити проблеми з певними групами вводу.
Умови помилок: перевірте різні способи, як ваш код може виникати збій або виникати помилки, особливо під час обробки винятків і звітування про помилки. 
Переконайтеся, що ваш код витончено обробляє ці сценарії.
Обмеження продуктивності: визначте обмеження продуктивності або ресурсів і протестуйте відповідно. 
Дізнайтеся, як ваша система поводиться під високим навантаженням, обмеженою пам’яттю чи іншими обмеженнями.
Поведінка користувача: нарешті, подумайте про те, як користувачі взаємодіють із вашою програмою, 
і перевірте будь-які незвичайні моделі використання або введення. Це може допомогти вам виявити проблеми, 
які виникають через неочікуваний вхід або дії користувача.
Підсумовуючи, C# і .NET пропонують багату екосистему для модульного тестування з різними потужними фреймворками та бібліотеками, такими як xUnit і Moq. 
Дотримуючись принципів, шаблонів і найкращих практик, розглянутих у цій статті, ви можете розробити всеосяжні модульні тести, які можна підтримувати, 
щоб забезпечити якість, стабільність і надійність ваших програм C#. Продовжуйте вчитися, практикуватися та вдосконалювати свої навички модульного тестування, 
щоб стати дедалі ефективнішим розробником.

