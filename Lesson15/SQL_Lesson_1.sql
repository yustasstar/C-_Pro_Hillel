--SQL Server є однією з найпопулярніших систем управління базами даних (СУБД) у світі. 
--Ця СУБД підходить для різних проектів: від невеликих додатків до великих високонавантажених проектів.
--SQL Server було створено компанією Microsoft. Перша версія вийшла 1987 року. 
--SQL Server довгий час був виключно системою керування базами даних для Windows, проте починаючи з версії 16 ця система доступна і на Linux.
--SQL Server характеризується такими особливостями як:
--Продуктивність. SQL Server працює дуже швидко.
--Надійність та безпека. SQL Server надає шифрування даних.
--Простота. З цієї СУБД щодо легко працювати та вести адміністрування.

--Центральним аспектом у MS SQL Server, як і будь-який СУБД, є база даних. 
--База даних представляє сховище даних, організованих певним способом. 
--Нерідко фізично база даних представляє файл на жорсткому диску, хоча така відповідність необов'язково. 
--Для зберігання та адміністрування баз даних застосовуються системи управління базами даних (database management system) або СУБД (DBMS). 
--І саме MS SQL Server є однією з таких СУБД.

--Для організації баз даних MS SQL Server використовує реляційну модель. Ця модель баз даних була розроблена ще в 1970 Едгаром Коддом. 
--А на сьогодні вона фактично є стандартом для організації баз даних.
--Реляційна модель передбачає зберігання даних у вигляді таблиць, кожна з яких складається з рядків та стовпців. 
--Кожен рядок зберігає окремий об'єкт, а стовпці розміщуються атрибути цього об'єкта.
--Для ідентифікації кожного рядка у межах таблиці застосовується первинний ключ (primary key).
--Як первинний ключ може виступати один або кілька стовпців. Використовуючи первинний ключ, ми можемо посилатися на певний рядок у таблиці. 
--Відповідно два рядки не можуть мати один і той же первинний ключ.
--Через ключі одна таблиця може бути пов'язана з іншою, тобто між двома таблицями можуть бути організовані зв'язки. 
--А сама таблиця може бути представлена ​​у вигляді відношення ("relation").

--Для взаємодії з базою даних використовується мова SQL (Structured Query Language). 
--Клієнт (наприклад, зовнішня програма) надсилає запит мовою SQL за допомогою спеціального API. 
--СУБД належним чином інтерпретує та виконує запит, а потім надсилає клієнту результат виконання.

--Спочатку мова SQL була розроблена в компанії IBM для системи баз даних, яка називалася System/R. 
--При цьому сама мова називалася SEQUEL (Structured English Query Language). 
--Хоча в результаті ні база даних, ні сама мова не згодом були офіційно опубліковані, 
--за традицією сам термін SQL нерідко вимовляють як "сіквел".

--1979 року компанія Relational Software Inc. розробила першу систему управління баз даних, 
--яка називалася Oracle і використовувала мову SQL. У зв'язку з успіхом цього продукту компанія була перейменована на Oracle.

--Згодом почали з'являтися інші системи баз даних, які використовували SQL. 
--У результаті в 1989 році Американський Національний Інститут Стандартів (ANSI) кодифікував мову та опублікував її перший стандарт. 
--Після цього стандарт періодично оновлювався та доповнювався. Останнє його оновлення відбулося у 2011 році. 
--Але незважаючи на наявність стандарту нерідко виробники СУБД використовують власні реалізації мови SQL, 
--які трохи відрізняються один від одного.

--Виділяються два різновиди мови SQL: PL-SQL та T-SQL. 
--PL-SQL використовується у таких СУБД як Oracle та MySQL. 
--T-SQL (Transact-SQL) застосовується у SQL Server. Саме тому в рамках поточного керівництва розглядатиметься саме T-SQL.

--Залежно від завдання, яке виконує команда T-SQL, він може належати до одного з таких типів:
--DDL (Data Definition Language/Мова визначення даних). До цього типу належать різні команди, 
--які створюють базу даних, таблиці, індекси, процедури, що зберігаються і т.д. Загалом визначають дані.
--Зокрема, до цього типу ми можемо віднести такі команди:

--CREATE : створює об'єкти бази даних (саму базу даних, таблиці, індекси тощо)
--ALTER : змінює об'єкти бази даних
--DROP : видаляє об'єкти бази даних
--TRUNCATE : видаляє всі дані з таблиць

--DML (Data Manipulation Language/Мова маніпуляції даними). 
--До цього типу відносять команди з вибору даних, їх оновлення, додавання, видалення - загалом усі команди, 
--з допомогою якими ми можемо управляти даними.

--До цього типу належать такі команди:
    --SELECT : отримує дані з БД
    --UPDATE : оновлює дані
    --INSERT : додає нові дані
    --DELETE : видаляє дані

--DCL (Data Control Language/Мова керування доступу до даних). 
--До цього типу відносять команди, які керують правами доступу до даних. Зокрема, це такі команди:
--GRANT : надає права на доступ до даних
--REVOKE : відкликає права на доступ до даних

--Базу даних часто ототожнюють із набором таблиць, які зберігають дані. 
--Але це зовсім так. Краще сказати, що база даних представляє сховище об'єктів. Основні з них:

--Таблиці : зберігають власне дані
--Уявлення (Views): вирази мови SQL, які повертають набір даних як таблиці
--Зберігають процедури : виконують код на мові SQL по відношенню до даних до БД (наприклад, отримує дані або змінює їх)
--Функції : також код SQL, який виконує певне завдання

--У SQL Server використовується два типи баз даних: системні та користувацькі. 
--Системні бази даних потрібні серверу SQL для коректної роботи. 
--А бази даних користувача створюються користувачами сервера і можуть зберігати будь-яку довільну інформацію. 
--Їх можна змінювати та видаляти, створювати заново. Власне це бази даних, які ми будемо створювати і з якими ми працюватимемо.

--Системні бази даних:
--У MS SQL Server за умовчанням створюється чотири системні бази даних:

--master : ця головна база даних сервера, у разі відсутності або пошкодження сервер не зможе працювати. 
--Вона зберігає всі логіни користувачів сервера, їх ролі, різні конфігураційні налаштування, імена та інформацію про бази даних, 
--які зберігаються на сервері, а також ряд іншої інформації.

--model : ця база даних представляє шаблон, основі якого створюються інші бази даних. 
--Тобто, коли ми створюємо через SSMS свою бд, вона створюється як копія бази model.

--msdb : зберігає інформацію про роботу, яку виконує такий компонент як планувальник SQL. 
--Також вона зберігає інформацію про бекапи баз даних.

--tempdb : Ця база даних використовується як сховище для тимчасових об'єктів. 
--Вона знову перетворюється при кожному запуску сервера.

--Всі ці бази можна побачити через SQL Server Management Studio у вузлі Databases -> System Databases
--Ці бази даних не слід змінювати, крім бд model.

--Якщо на етапі встановлення сервера було обрано та встановлено компонент PolyBase, 
--то також на сервері за умовчанням будуть розташовані ще три бази даних, 
--які використовуються цим компонентом: DWConfiguration, DWDiagnostics, DWQueue.
--##########################################################################################

--Тепер створимо свою базу даних. 
--Для цього ми можемо використовувати скрипт на мові SQL або все зробити за допомогою графічних засобів в SQL Management Studio. 
--У разі ми виберемо другий спосіб. Для цього відкриємо SQL Server Management Studio і натиснемо правою кнопкою миші на вузол Databases . 
--Потім у контекстному меню виберемо пункт New Database
--Після цього нам відкривається вікно для створення бази даних
--У полі Database необхідно запровадити назву нової бд. Нехай у нас база даних називається university .
--Наступне поле Owner задає власника бази даних. За умовчанням воно має значення <defult> , 
--тобто власником буде той, хто створює цю базу даних. Залишимо це поле без змін.
--Далі йде таблиця для встановлення загальних налаштувань бази даних. 
--Вона містить два рядки - перший для установки налаштувань для головного файлу, 
--де зберігатимуться дані, і другий рядок для конфігурації файлу логування. Зокрема, ми можемо встановити такі налаштування:

--Logical Name : логічне ім'я, яке присвоюється файлу бази даних.
--File Type : є кілька типів файлів, але, як правило, основна робота ведеться з файлами даних (ROWS Data) та файлом лога (LOG)
--Filegroup : позначає групу файлів. 
--Група файлів може зберігати безліч файлів і може використовуватися для розбиття бази даних на частини для розміщення у різних місцях.
--Initial Size (MB) : встановлює початковий розмір файлів під час створення (фактичний розмір може відрізнятися від цього значення).
--Autogrowth/Maxsize : при досягненні бази даних початкового розміру SQL Server використовує це значення для збільшення файлу.
--Path : каталог, де зберігатимуться бази даних.
--File Name : безпосереднє ім'я фізичного файлу. Якщо вона не зазначена, то застосовується логічне ім'я.

--Після введення назви бази даних натиснемо кнопку ОК, і бд буде створена.
--Після цього з'явиться серед баз даних сервера. Якщо ця бд згодом не буде потрібна, 
--то її можна видалити, натиснувши на неї правою кнопкою миші та вибравши в контекстному меню пункт Delete
--##########################################################################################

--Ключовим об'єктом у базі даних є таблиці. Таблиці складаються з рядків та стовпців. 
--Стовпці визначають тип інформації, що зберігається, а рядки містять значення цих стовпців.
--Минулої теми було створено базу даних university. Тепер визначимо у ній першу таблицю. 
--Знову ж таки для створення таблиці в SQL Server Management Studio можна застосувати скрипт мовою SQL, 
--або скористатися графічним дизайнером. У разі виберемо друге.

--Для цього розкриємо вузол бази даних university в SQL Server Management Studio, 
--натиснемо на його подузол Tables правою кнопкою миші і далі в контексті меню виберемо New -> Table...

--Після цього відкриється дизайнер таблиці. 
--У центральній частині таблиці необхідно ввести дані про стовпці таблиці. 
--Дизайнер містить три поля:

--Column Name : ім'я стовпця
--Data Type : тип даних стовпця. Тип даних визначає, які дані можуть зберігатися у цьому стовпці. 
--Наприклад, якщо стовпець представляє числовий тип, він може зберігати лише числа.

--Allow Nulls : чи може бути відсутнє значення у стовпця, тобто чи може він бути порожнім

--Допустимо, нам треба створити таблицю з даними учнів у навчальному закладі. 
--Для цього у дизайнері таблиці чотири стовпці: Id, FirstName, LastName та Year,
--які будуть представляти відповідно унікальний ідентифікатор користувача, його ім'я, прізвище та рік народження. 
--У першого і четвертого стовпця треба вказати тип int (тобто цілий), а у стовпців FirstName і LastName - тип nvarchar(50) (рядковий).

--Потім у вікні Properties, яка містить властивості таблиці, 
--в полі Name треба ввести ім'я таблиці - Students , а в полі Identity ввести Id, тобто вказуючи, що стовпець Id буде ідентифікатором.

--Ім'я таблиці має бути унікальним у межах бази даних. 
--Як правило, назва таблиці відображає назву сутності, яка зберігається в ній. 
--Наприклад, ми хочемо зберегти студентів, тому таблиця називається Students (слово студент у множині англійською мовою). 
--Існують різні думки з приводу того, чи варто використовувати назву сутності в однині або множині (Student або Students). 
--У разі питання найменування таблиці повністю лягає на розробника бази даних.

--І наприкінці нам слід зазначити, що стовпець Id виконуватиме роль первинного ключа (primary key). 
--Первинний ключ унікально ідентифікує кожен рядок. У ролі первинного ключа може бути один стовпець, а може й кілька.
--Для встановлення первинного ключа натиснемо на стовпець Id правою кнопкою миші і в меню виберемо пункт Set Primary Key .
--Після цього навпроти поля Id має з'явитися золотий ключик. Цей ключик вказуватиме, що стовпець Id виконуватиме роль первинного ключа.

--І після збереження у базі даних university з'явиться таблиця Students:

--Ми можемо помітити, що назва таблиці фактично починається з префікса dbo . 
--Цей префікс представляє схему. Схема визначає контейнер, що зберігає об'єкти. 
--Тобто схема логічно розмежовує бази даних.
--Якщо схема явним чином не вказується при створенні об'єкта, об'єкт належить схемі за умовчанням - схемою dbo .

--Натисніть правою кнопкою миші на назву таблиці, і нам відобразиться контекстне меню з опціями

--За допомогою цих опцій можна керувати таблицею. Так, опція Delete дозволяє вилучити таблицю. 
--Опція Design відкриє вікно дизайнера таблиці, де ми можемо за потреби внести зміни до її структури.

--Для додавання початкових даних можна вибрати опцію Edit Top 200 Rows . 
--Вона відкриває у вигляді таблиці 200 перших рядків та дозволяє їх змінити. Але так як у нас таблиця тільки створена, то, звичайно, 
--в ній буде ніяких даних. Введемо пару рядків – пару студентів, вказавши необхідні дані для стовпців

--У цьому випадку я додав два рядки.

--Потім знову ж таки по кліку на таблицю правою кнопкою миші ми можемо вибрати в контекстному меню пункт 
--Select Top 1000 Rows і буде запущено скрипт, який відобразить перші 1000 рядків з таблиці

--##########################################################################################
--Під час створення таблиці всім її стовпців необхідно вказати певний тип даних. 
--Тип даних визначає, які значення можуть зберігатися в стовпці, скільки вони займатимуть місця у пам'яті.
--Мова T-SQL надає багато різних типів. Залежно від характеру значень їх можна розділити на групи.
--##########################################################################################

--Числові типи даних:
--BIT : зберігає значення від 0 до 16. 
	--Може виступати аналогом булевого типу у мовах програмування (у разі значення true відповідає 1, а значення false - 0). 
	--При значеннях до 8 (включно) займає 1 байт, при значеннях від 9 до 16 – 2 байти.
--TINYINT : зберігає числа від 0 до 255. Займає 1 байт. Добре підходить для зберігання невеликих чисел.
--SMALLINT : зберігає числа від -32 768 до 32 767. Займає 2 байти
--INT : зберігає числа від -2147483648 до 2147483647. Займає 4 байти. Найбільш використовуваний тип зберігання чисел.
--BIGINT : зберігає дуже великі числа від -9223372036854775808 до 9223372036854775807, які займають у пам'яті 8 байт.
--DECIMAL : зберігає числа з фіксованою точністю. Займає від 5 до 17 байт залежно від кількості чисел після коми.
	--Цей тип може приймати два параметри precision і scale: DECIMAL(precision, scale).
	--Параметр precision представляє максимальну кількість цифр, які можуть зберігати число. 
	--Це значення має знаходитися в діапазоні від 1 до 38. За замовчуванням воно дорівнює 18.
	--Параметр scale представляє максимальну кількість цифр, які можуть містити число після коми. 
	--Це значення має знаходитися в діапазоні від 0 до значення параметра precision. За умовчанням воно дорівнює 0.
--NUMERIC : даний тип аналогічний типу DECIMAL.
--SMALLMONEY : зберігає дробові значення від -214748.3648 до 214748.3647. Призначений для зберігання грошових величин. 
	--Займає 4 байти. Еквівалентний типу DECIMAL(10,4).
--MONEY : зберігає дробові значення від -922337203685477.5808 до 922337203685477.5807. Представляє грошові величини та займає 8 байт. 
	--Еквівалентний типу DECIMAL(19,4).
--FLOAT : зберігає цифри від –1.79E+308 до 1.79E+308. Займає від 4 до 8 байт залежно від дрібної частини.
	--Може мати форму визначення у вигляді FLOAT(n), де n є число біт, які використовуються для зберігання десяткової частини числа (мантиси). 
	--За промовчанням n = 53.
--REAL : зберігає цифри від –340E+38 to 3.40E+38. Займає 4 байти. Еквівалентний типу FLOAT(24).
-----
--Типи даних, що представляють дату та час
--DATE : зберігає дати від 0001-01-01 (1 січня 0001 року) до 9999-12-31 (31 грудня 9999 року). Займає 3 байти.
--TIME : зберігає час у діапазоні від 00:00:00.0000000 до 23:59:59.9999999. Займає від 3 до 5 байт.
	--Може мати форму TIME(n), де n представляє кількість цифр від 0 до 7 у дрібній частині секунд.
--DATETIME : зберігає дати та час від 01/01/1753 до 31/12/9999. Займає 8 байт.
--DATETIME2 : зберігає дати та час у діапазоні від 01/01/0001 00:00:00.0000000 до 31/12/9999 23:59:59.9999999. 
	--Займає від 6 до 8 байт, залежно від точності часу.
	--Може мати форму DATETIME2(n), де n представляє кількість цифр від 0 до 7 у дрібній частині секунд.
--SMALLDATETIME : зберігає дати та час у діапазоні від 01/01/1900 до 06/06/2079, тобто найближчі дати. Займає від 4 байти.
--DATETIMEOFFSET : зберігає дати та час у діапазоні від 0001-01-01 до 9999-12-31. 
	--Зберігає детальну інформацію про час з точністю до 100 наносекунд. Займає 10 байт.

--Поширені формати дат:
-- yyyy-mm-dd-2017-07-12
--dd/mm/yyyy-12/07/2017
--mm-dd-yy-07-12-17

--У такому форматі двоцифрові числа від 00 до 49 сприймаються як дати в діапазоні 2000-2049. 
--А числа від 50 до 99 як діапазон чисел 1950 – 1999.

--Month dd, yyyy-July 12, 2017

--Розповсюджені формати часу:
--hh:mi-13:21
--hh:mi am/pm-1:21 pm
--hh:mi:ss-1:21:34
--hh:mi:ss:mmm-1:21:34:12
--hh:mi:ss:nnnnnnn-1:21:34:1234567

--Рядкові типи даних
--CHAR : зберігає рядок довжиною від 1 до 8000 символів. На кожен символ виділяє по 1 байти. 
	--Не підходить для багатьох мов, оскільки зберігає символи не в кодуванні Unicode.
	--Кількість символів, які можуть зберігати стовпець, передається в дужках. Наприклад, для стовпця з типом CHAR(10)буде виділено 10 байт. 
	--І якщо ми збережемо в стовпці рядок менше 10 символів, то він буде доповнений пробілами.
--VARCHAR : зберігає рядок. На кожен символ виділяється 1 байт. 
	--Можна вказати конкретну довжину стовпця - від 1 до 8 000 символів, наприклад, VARCHAR(10). 
	--Якщо рядок повинен мати більше 8000 символів, то визначається розмір MAX, а на зберігання рядка може виділятися до 2 Гб: VARCHAR(MAX).
	--Не підходить для багатьох мов, оскільки зберігає символи не в кодуванні Unicode.
	--На відміну від типу CHAR якщо в стовпець з типом VARCHAR(10)буде збережено рядок 5 символів, 
	--то в столці буде збережено саме п'ять символів.
--NCHAR : зберігає рядок у кодуванні Unicode довжиною від 1 до 4000 символів. На кожен символ виділяється 2 байти. Наприклад,NCHAR(15)
--NVARCHAR : зберігає рядок у кодуванні Unicode. На кожен символ виділяється 2 байти. 
	--Можна задати конкретний розмір від 1 до 4 000 символів: . Якщо рядок повинен мати більше 4000 символів, то визначається розмір MAX, а на зберігання рядка може виділятися до 2 Гб.
--TEXT/NTEXT - Ще два типи TEXT та NTEXT є застарілими і тому їх не рекомендується використовувати. 
--Замість них застосовуються VARCHAR та NVARCHAR відповідно.
------
--Бінарні типи даних
--BINARY : зберігає бінарні дані у вигляді послідовності від 1 до 8000 байт.
--VARBINARY : зберігає бінарні дані як послідовності від 1 до 8 000 байт, або до 2^31–1 байт під час 
	--використання значення MAX (VARBINARY(MAX)).

--Ще один бінарний тип – тип IMAGE є застарілим, і замість нього рекомендується застосовувати тип VARBINARY.

--Інші типи даних
--UNIQUEIDENTIFIER : унікальний ідентифікатор GUID (насправді рядок з унікальним значенням), який займає 16 байт.
--TIMESTAMP : деяке число, яке зберігає номер версії рядка таблиці. Займає 8 байт.
--CURSOR : представляє набір рядків.
--HIERARCHYID : представляє позицію в ієрархії.
--SQL_VARIANT : може зберігати дані будь-якого іншого типу даних T-SQL.
--XML : зберігає документи XML або фрагменти документів XML. Займає у пам'яті до 2 Гб.
--TABLE : подає визначення таблиці.
--GEOGRAPHY : зберігає географічні дані, такі як широта та довгота.
--GEOMETRY : зберігає координати місцезнаходження на площині.
--##########################################################################################

create database InternetShop -- створення бази даних під назвою InternetShop
go -- роздільник пакетів. Пакет - набір команд, які виконуються в рамках запиту.
use InternetShop -- встановлюємо з'єднання із створеною базою

-- Можлива ситуація, що ми вже маємо файл бази даних, який, наприклад, створено на іншому комп'ютері.
-- Файл бази даних представляє файл з розширенням mdf, і цей файл ми можемо переносити.
-- Однак навіть якщо ми скопіюємо його комп'ютер із встановленим MS SQL Server, просто так скопійована база даних на сервері не з'явиться.

-- Для цього необхідно виконати прикріплення бази даних до сервера.
-- У цьому випадку застосовується вираз

--CREATE DATABASE название_базы_данных
--ON PRIMARY(FILENAME='путь_к_файлу_mdf_на_локальном_компьютере')
--FOR ATTACH;
-----
-- видалення бази даних
-- drop database InternetShop
-------
-- створення таблиці
-- CREATE TABLE Customers
-- (
--     Id INT,
--     Age INT,
--     FirstName NVARCHAR(20),
--     LastName NVARCHAR(20),
--     Email VARCHAR(30),
--     Phone VARCHAR(20)
-- );

-- Перейменування таблиці
-- EXEC sp_rename 'Customers', 'Clients';

-- видалення таблиці
-- DROP TABLE Customers

--##########################################################################################
--IDENTITY  - дозволяє зробити стовпець ідентифікатором. 
    --Цей атрибут може бути призначений для стовпців числових типів INT, SMALLINT, BIGINT, TYNIINT, DECIMAL і NUMERIC. 
    --При додаванні нових даних до таблиці SQL Server інкрементуватиме на одиницю значення цього стовпця в останньому записі. 
    --Як правило, у ролі ідентифікатора виступає той самий стовпець, який є первинним ключем, хоча в принципі це необов'язково.
--UNIQUE - Якщо ми хочемо, щоб стовпець мав лише унікальні значення, то для нього можна визначити атрибут UNIQUE .
--NOT NULL/NULL - Щоб вказати, чи може стовпець приймати значення NULL, при визначенні стовпця можна задати атрибут NULL або NOT NULL . 
    --Якщо цей атрибут явно не буде використаний, то за умовчанням стовпець допускатиме значення NULL. 
    --Винятком є ​​той випадок, коли стовпець виступає ролі первинного ключа - у разі за умовчанням стовпець має значення NOT NULL.
--DEFAULT - Атрибут DEFAULT визначає значення за промовчанням для стовпця. 
    --Якщо при додаванні даних для стовпця не буде передбачено значення, то для нього використовуватиметься значення за замовчуванням.
--CHECK - Ключове слово CHECK визначає обмеження для діапазону значень, які можуть зберігатися в стовпці. 
    --Для цього після слова CHECK вказується в дужках умова, якій має відповідати стовпець або кілька стовпців.

-- CREATE TABLE Customers
-- (
--     Id INT PRIMARY KEY IDENTITY (1, 1), -- IDENTITY(seed, increment)
--     Age INT NULL DEFAULT 18 CHECK(Age > 0 AND Age < 100),
--     FirstName NVARCHAR(20) NOT NULL,
--     LastName NVARCHAR(20) NOT NULL,
--     Email VARCHAR(30) UNIQUE,
--     Phone VARCHAR(20) UNIQUE
-- )

-- v2
--CREATE TABLE Customers
--(
--    Id INT PRIMARY KEY IDENTITY (1, 1),
--    Age INT,
--    FirstName NVARCHAR(20),
--    LastName NVARCHAR(20),
--    Email VARCHAR(30),
--    Phone VARCHAR(20),
--    UNIQUE(Email, Phone)
--)

-- v3
-- CREATE TABLE Customers
-- (
--    Id INT PRIMARY KEY IDENTITY,
--    Age INT DEFAULT 18,
--    FirstName NVARCHAR(20) NOT NULL,
--    LastName NVARCHAR(20) NOT NULL,
--    Email VARCHAR(30) UNIQUE,
--    Phone VARCHAR(20) UNIQUE,
--    CHECK((Age >0 AND Age<100) AND (Email !='') AND (Phone !=''))
-- )

-- За допомогою ключового слова CONSTRAINT можна встановити ім'я для обмежень. 
-- Як обмеження можуть використовуватися PRIMARY KEY, UNIQUE, DEFAULT, CHECK.
-- Імена обмежень можна встановити на рівні стовпців. Вони вказуються після CONSTRAINT перед атрибутами:

-- CREATE TABLE Customers
-- (
--    Id INT CONSTRAINT PK_Customer_Id PRIMARY KEY IDENTITY,
--    Age INT
--        CONSTRAINT DF_Customer_Age DEFAULT 18 
--        CONSTRAINT CK_Customer_Age CHECK(Age >0 AND Age < 100),
--    FirstName NVARCHAR(20) NOT NULL,
--    LastName NVARCHAR(20) NOT NULL,
--    Email VARCHAR(30) CONSTRAINT UQ_Customer_Email UNIQUE,
--    Phone VARCHAR(20) CONSTRAINT UQ_Customer_Phone UNIQUE
-- )

--##########################################################################################
--Обмеження можуть носити довільні назви, але, як правило, застосовуються такі префікси:

    --"PK_" - для PRIMARY KEY
    --"FK_" - для FOREIGN KEY
    --"CK_" - для CHECK
    --"UQ_" - для УНІКАЛЬНОГО
    --"DF_" - для DEFAULT

--В принципі необов'язково вказувати імена обмежень, при установці відповідних атрибутів SQL Server автоматично визначає їх імена. 
--Але знаючи ім'я обмеження, ми можемо до нього звертатися, наприклад, для його видалення.

CREATE TABLE Customers_2
(
    Id INT IDENTITY,
    Age INT CONSTRAINT DF_Customer_Age DEFAULT 18, 
    FirstName NVARCHAR(20) NOT NULL,
    LastName NVARCHAR(20) NOT NULL,
    Email VARCHAR(30),
    Phone VARCHAR(20),
    CONSTRAINT PK_Customer_Id PRIMARY KEY (Id), 
    CONSTRAINT CK_Customer_Age CHECK(Age >0 AND Age < 100),
    CONSTRAINT UQ_Customer_Email UNIQUE (Email),
    CONSTRAINT UQ_Customer_Phone UNIQUE (Phone)
)

--##########################################################################################
--Зовнішні ключі використовуються для встановлення зв'язку між таблицями. 
--Зовнішній ключ встановлюється для стовпців із залежної, підлеглої таблиці, і вказує на один із стовпців із головної таблиці. 
--Хоча, як правило, зовнішній ключ вказує на первинний ключ із пов'язаної головної таблиці, 
--але це необов'язково має бути неодмінною умовою. Зовнішній ключ також може вказувати на інший стовпець, який має унікальне значення.

--[FOREIGN KEY] REFERENCES главная_таблица (столбец_главной_таблицы)
--    [ON DELETE {CASCADE|NO ACTION}]
--    [ON UPDATE {CASCADE|NO ACTION}]

--Для створення обмеження зовнішнього ключа на рівні стовпця після ключового слова REFERENCES вказується ім'я пов'язаної таблиці 
--та у круглих дужках ім'я зв'язаного стовпця, на який вказуватиме зовнішній ключ. 
--Також зазвичай додаються ключові слова FOREIGN KEY , але їх необов'язково вказувати. 
--Після виразу REFERENCES йде вираз ON DELETE та ON UPDATE .

-- CREATE TABLE Customers
-- (
--     Id INT PRIMARY KEY IDENTITY,
--     Age INT DEFAULT 18, 
--     FirstName NVARCHAR(20) NOT NULL,
--     LastName NVARCHAR(20) NOT NULL,
--     Email VARCHAR(30) UNIQUE,
--     Phone VARCHAR(20) UNIQUE
-- );
 
--  -- v1
-- CREATE TABLE Orders
-- (
--    Id INT PRIMARY KEY IDENTITY,
--    CustomerId INT REFERENCES Customers (Id),
--    CreatedAt Date
-- );

-- -- v2
-- CREATE TABLE Orders
-- (
--    Id INT PRIMARY KEY IDENTITY,
--    CustomerId INT,
--    CreatedAt Date,
--    FOREIGN KEY (CustomerId)  REFERENCES Customers (Id)
-- );

-- v3 (лучший вариант)
CREATE TABLE Orders
(
    Id INT PRIMARY KEY IDENTITY,
    CustomerId INT,
    CreatedAt Date,
    CONSTRAINT FK_Orders_To_Customers FOREIGN KEY (CustomerId)  REFERENCES Customers (Id)
);

-- ON DELETE / ON UPDATE
--За допомогою виразів ON DELETE та ON UPDATE можна встановити дії, 
--які виконуватимуться відповідно при видаленні та зміні зв'язаного рядка з головної таблиці. 
--І для визначення дії ми можемо використовувати такі опції:

--CASCADE : автоматично видаляє або змінює рядки із залежної таблиці під час видалення або зміни пов'язаних рядків у головній таблиці.

-- CREATE TABLE Orders
-- (
--     Id INT PRIMARY KEY IDENTITY,
--     CustomerId INT,
--     CreatedAt Date,
--     FOREIGN KEY (CustomerId) REFERENCES Customers (Id) ON DELETE CASCADE
-- )

--NO ACTION : запобігає будь-яким діям у залежній таблиці при видаленні або зміні зв'язаних рядків у головній таблиці. 
--Тобто фактично якихось дій відсутні.

-- CREATE TABLE Orders
-- (
--     Id INT PRIMARY KEY IDENTITY,
--     CustomerId INT,
--     CreatedAt Date,
--     FOREIGN KEY (CustomerId) REFERENCES Customers (Id) ON DELETE NO ACTION
-- );

--SET NULL : при видаленні зв'язаного рядка з головної таблиці встановлює значення NULL для стовпця зовнішнього ключа.

-- CREATE TABLE Orders
-- (
--     Id INT PRIMARY KEY IDENTITY,
--     CustomerId INT,
--     CreatedAt Date,
--     FOREIGN KEY (CustomerId) REFERENCES Customers (Id) ON DELETE SET NULL
-- );

--SET DEFAULT : при видаленні зв'язаного рядка з головної таблиці встановлює для стовпчика зовнішнього ключа значення за промовчанням, 
--яке задається за допомогою атрибута DEFAULT. Якщо для стовпця не встановлено значення за умовчанням, 
--то як нього застосовується значення NULL.

-- CREATE TABLE Orders
-- (
--     Id INT PRIMARY KEY IDENTITY,
--     CustomerId INT,
--     CreatedAt Date,
--     FOREIGN KEY (CustomerId) REFERENCES Customers (Id) ON DELETE SET DEFAULT
-- )

--##########################################################################################
--Можливо, в якийсь момент ми захочемо змінити таблицю, що вже є. 
--Наприклад, додати або видалити стовпці, змінити тип стовпців, додати або видалити обмеження. 
--Тобто потрібно змінити визначення таблиці. Для зміни таблиць використовується вираз ALTER TABLE .

--ALTER TABLE название_таблицы [WITH CHECK | WITH NOCHECK]
--  ADD название_столбца тип_данных_столбца [атрибуты_столбца] | 
--  DROP COLUMN название_столбца |
--  ALTER COLUMN название_столбца тип_данных_столбца [NULL|NOT NULL] |
--  ADD [CONSTRAINT] определение_ограничения |
--  DROP [CONSTRAINT] имя_ограничения

-- Додавання нового стовпця
ALTER TABLE Customers
ADD Address NVARCHAR(50) NOT NULL DEFAULT 'No Info';

-- Видалення стовпця
ALTER TABLE Customers
DROP COLUMN Address;

-- Зміна типу стовпця
ALTER TABLE Customers
ALTER COLUMN FirstName NVARCHAR(200);

-- Додавання обмеження CHECK
ALTER TABLE Customers
ADD CHECK (Age > 21);

--Якщо в таблиці є рядки, в яких у стовпці Age є значення, що не відповідають цьому обмеженню, то команда SQL завершиться з помилкою. 
--Щоб уникнути подібної перевірки на відповідність і додати обмеження, незважаючи на наявність невідповідних йому даних, 
--використовується вираз WITH NOCHECK

ALTER TABLE Customers WITH NOCHECK
ADD CHECK (Age > 21);

-- За замовчуванням використовується значення WITH CHECK , яке перевіряє відповідність обмеженням.
--##########################################################################################
-- Додавання зовнішнього ключа
-- Нехай спочатку до бази даних буде додано дві таблиці, ніяк не пов'язані:
-- CREATE TABLE Customers
-- (
--     Id INT PRIMARY KEY IDENTITY,
--     Age INT DEFAULT 18, 
--     FirstName NVARCHAR(20) NOT NULL,
--     LastName NVARCHAR(20) NOT NULL,
--     Email VARCHAR(30) UNIQUE,
--     Phone VARCHAR(20) UNIQUE
-- );
-- CREATE TABLE Orders
-- (
--     Id INT IDENTITY,
--     CustomerId INT,
--     CreatedAt Date
-- );

-- Додамо обмеження зовнішнього ключа до стовпця CustomerId таблиці Orders:
ALTER TABLE Orders
ADD FOREIGN KEY(CustomerId) REFERENCES Customers(Id);

-- Додавання первинного ключа
ALTER TABLE Orders
ADD PRIMARY KEY (Id);

-- Додавання обмежень з іменами
ALTER TABLE Orders
ADD CONSTRAINT PK_Orders_Id PRIMARY KEY (Id),
    CONSTRAINT FK_Orders_To_Customers FOREIGN KEY(CustomerId) REFERENCES Customers(Id);
 
ALTER TABLE Customers
ADD CONSTRAINT CK_Age_Greater_Than_Zero CHECK (Age > 0);

-- Видалення обмежень
ALTER TABLE Orders
DROP FK_Orders_To_Customers;

--##########################################################################################
-- Основи T-SQL. DML:

-- Для додавання даних застосовується команда INSERT , яка має такий формальний синтаксис:
-- INSERT [INTO] имя_таблицы [(список_столбцов)] VALUES (значение1, значение2, ... значениеN)

CREATE TABLE Products2
(
    Id INT IDENTITY PRIMARY KEY,
    ProductName NVARCHAR(30) NOT NULL,
    Manufacturer NVARCHAR(20) NOT NULL,
    ProductCount INT DEFAULT 0,
    Price MONEY NOT NULL
)

INSERT Products VALUES ('iPhone 7', 'Apple', 5, 52000)

INSERT INTO Products 
VALUES
('iPhone 6', 'Apple', 3, 36000),
('Galaxy S8', 'Samsung', 2, 46000),
('Galaxy S8 Plus', 'Samsung', 1, 56000)

INSERT INTO Products (ProductName, Manufacturer, ProductCount, Price)
VALUES ('Mi6', 'Xiaomi', DEFAULT, 28000)

-- Якщо всі стовпці мають атрибут DEFAULT, який визначає значення за замовчуванням, або допускають значення NULL, 
-- то для всіх стовпців можна вставити значення за замовчуванням

INSERT INTO Products
DEFAULT VALUES

-- Для отримання даних застосовується команда SELECT . У спрощеному вигляді вона має наступний синтаксис:
-- SELECT список_столбцов FROM имя_таблицы

-- -- Наприклад, нехай раніше була створена таблиця Products, і до неї додані деякі початкові дані
-- CREATE TABLE Products
-- (
--     Id INT IDENTITY PRIMARY KEY,
--     ProductName NVARCHAR(30) NOT NULL,
--     Manufacturer NVARCHAR(20) NOT NULL,
--     ProductCount INT DEFAULT 0,
--     Price MONEY NOT NULL
-- );
 
-- INSERT INTO Products 
-- VALUES
-- ('iPhone 6', 'Apple', 3, 36000),
-- ('iPhone 6S', 'Apple', 2, 41000),
-- ('iPhone 7', 'Apple', 5, 52000),
-- ('Galaxy S8', 'Samsung', 2, 46000),
-- ('Galaxy S8 Plus', 'Samsung', 1, 56000),
-- ('Mi6', 'Xiaomi', 5, 28000),
-- ('OnePlus 5', 'OnePlus', 6, 38000)

-- -- Отримаємо всі об'єкти з цієї таблиці:

SELECT * FROM Products

-- Якщо нам треба отримати дані не по всіх, а по якихось конкретних стовпцях, 
-- то всі ці специфікації стовпців перераховуються через кому після SELECT
SELECT ProductName, Price FROM Products

-- Специфікація стовпця необов'язково має представляти його назву. 
-- Це може бути будь-який вираз, наприклад, результат арифметичної операції.
SELECT ProductName + ' (' + Manufacturer + ')', Price, Price * ProductCount 
FROM Products

-- За допомогою оператора AS можна змінити назву вихідного стовпця або визначити його псевдонім:
SELECT
ProductName + ' (' + Manufacturer + ')' AS ModelName, 
Price,  
Price * ProductCount AS TotalSum
FROM Products

-- Оператор DISTINCT дозволяє вибрати унікальні рядки. 
-- Наприклад, у нашому випадку в таблиці може бути по кілька товарів від тих самих виробників. Виберемо всіх виробників

-- SELECT DISTINCT Manufacturer
-- FROM Products

-- -- Вираз SELECT INTO дозволяє вибрати з однієї таблиці деякі дані до іншої таблиці, при цьому друга таблиця створюється автоматично.
-- SELECT ProductName + ' (' + Manufacturer + ')' AS ModelName, Price
-- -- INTO ProductSummary
-- -- FROM Products
 
-- SELECT * FROM ProductSummary

-- Після виконання цієї команди у базі даних буде створено ще одну таблицю ProductSummary, яка матиме два стовпці ModelName і Price, 
-- а дані для цих стовпців будуть взяті з таблиці Products:

-- -- Оператор ORDER BY дозволяє відсортувати видобуті значення за певним стовпцем
-- SELECT *
-- FROM Products
-- ORDER BY ProductName

-- -- Сортування також можна проводити за псевдонімом стовпця, який визначається за допомогою оператора AS
-- SELECT ProductName, ProductCount * Price AS TotalSum
-- FROM Products
-- ORDER BY TotalSum

-- За умовчанням застосовується сортування за зростанням (ASC). За допомогою додаткового оператора DESC можна задати сортування за спаданням.
SELECT ProductName
FROM Products
ORDER BY ProductName DESC

--
SELECT ProductName
FROM Products
ORDER BY ProductName ASC

--
SELECT ProductName, Price, Manufacturer
FROM Products
ORDER BY Manufacturer, ProductName

-- 
SELECT ProductName, Price, Manufacturer
FROM Products
ORDER BY Manufacturer ASC, ProductName DESC

--
SELECT ProductName, Price, ProductCount
FROM Products
ORDER BY ProductCount * Price

-----------------------------------------
-- Оператор TOP дозволяє вибрати певну кількість рядків із таблиці
SELECT TOP 4 ProductName
FROM Products

-- Додатковий оператор PERCENT дозволяє вибрати відсоткову кількість рядків із таблиці. Наприклад, виберемо 75% рядків:
SELECT TOP 75 PERCENT ProductName
FROM Products

-- Оператор TOP дозволяє витягти певну кількість рядків, починаючи з початку таблиці. 
-- Для вилучення набору рядків з будь-якого місця застосовуються оператори OFFSET і FETCH . 
-- Важливо, що ці оператори застосовуються лише у відсортованому наборі даних після виразу ORDER BY.

-- Наприклад, виберемо всі рядки, починаючи з третього:
SELECT * FROM Products
ORDER BY Id 
    OFFSET 2 ROWS;

-- Тепер виберемо лише три рядки, починаючи з третього:
SELECT * FROM Products
ORDER BY Id 
    OFFSET 2 ROWS
    FETCH NEXT 3 ROWS ONLY;
-- FETCH FIRST 3 ROWS ONLY;

-- Після оператора FETCH вказується ключове слово FIRST або NEXT (яке саме в даному випадку не має значення) 
-- і потім вказується кількість рядків, які треба отримати.

-- Ця комбінація операторів зазвичай використовується для посторінкової навігації, коли необхідно отримати певну сторінку з даними.

-----------------------------------
-- Для фільтрації в команді SELECT застосовується оператор WHERE . Після цього оператора ставиться умова, якій має відповідати рядок
--	WHERE умова

--Якщо умова є істинною, то рядок потрапляє в результуючу вибірку. Як можна використовувати операції порівняння. 
--Ці операції порівнюють два вирази. У T-SQL можна застосовувати такі операції порівняння:

-- = : порівняння на рівність (на відміну від сі-подібних мов у T-SQL для порівняння на рівність використовується один знак одно)
-- <>  порівняння нерівностей
-- <  менше ніж
-- >  більше ніж
-- !<  не менше ніж
-- !>  не більше ніж
-- <=  менше ніж або дорівнює
-- >=  більше ніж або одно
--
SELECT * FROM Products
WHERE Manufacturer = 'Samsung'
--
SELECT * FROM Products
WHERE Price > 45000
--
SELECT * FROM Products
WHERE Price * ProductCount > 200000

-- AND : операція логічного І. Вона об'єднує два вирази
SELECT * FROM Products
WHERE Manufacturer = 'Samsung' AND Price > 50000

-- OR : операція логічного АБО. Вона також поєднує два вирази
SELECT * FROM Products
WHERE Manufacturer = 'Samsung' OR Price > 50000

-- NOT : операція логічного заперечення. Якщо вираз у цій операції помилкове, то загальна умова є істинною.
SELECT * FROM Products
WHERE NOT Manufacturer = 'Samsung'

-- v2
SELECT * FROM Products
WHERE Manufacturer <> 'Samsung'
-- 
SELECT * FROM Products
WHERE Manufacturer = 'Samsung' OR Price > 30000 AND ProductCount > 2
--
SELECT * FROM Products
WHERE (Manufacturer = 'Samsung' OR Price > 30000) AND ProductCount > 2
--
SELECT * FROM Products
WHERE ProductCount IS NULL
--
SELECT * FROM Products
WHERE ProductCount IS NOT NULL

--##########################################################################################
-- Оператор IN дозволяє визначити набір значень, які мають стовпці:
SELECT * FROM Products
WHERE Manufacturer IN ('Samsung', 'Xiaomi', 'Huawei')
-- v2
SELECT * FROM Products
WHERE Manufacturer = 'Samsung' OR Manufacturer = 'Xiaomi' OR Manufacturer = 'Huawei'
--
SELECT * FROM Products
WHERE Manufacturer NOT IN ('Samsung', 'Xiaomi', 'Huawei')

-- Оператор BETWEEN визначає діапазон значень за допомогою початкового та кінцевого значення, якому має відповідати вираз
SELECT * FROM Products
WHERE Price BETWEEN 20000 AND 40000
--
SELECT * FROM Products
WHERE Price NOT BETWEEN 20000 AND 40000
--
SELECT * FROM Products
WHERE Price * ProductCount BETWEEN 100000 AND 200000
--##########################################################################################
-- Оператор LIKE приймає шаблон рядка, якому має відповідати вираз.
-- WHERE выражение [NOT] LIKE шаблон_строки

--Для визначення шаблону може застосовуватися ряд спеціальних символів підстановки:
--% : відповідає будь-якому підрядку, який може мати будь-яку кількість символів, при цьому підрядок може і не містити жодного символу
--_ : відповідає будь-якому одиночному символу
--[ ] : відповідає одному символу, який вказаний у квадратних дужках
--[ - ] : відповідає одному символу з певного діапазону
--[ ^ ] : відповідає одному символу, який не вказано після символу ^

--Деякі приклади використання підстановок:

--WHERE ProductName LIKE 'Galaxy%'
--Відповідає таким значенням як "Galaxy Ace 2" або "Galaxy S7"

--WHERE ProductName LIKE 'Galaxy S_'
--Відповідає таким значенням як "Galaxy S7" або "Galaxy S8"

--WHERE ProductName LIKE 'iPhone [78]'
--Відповідає таким значенням як iPhone 7 або iPhone8

--WHERE ProductName LIKE 'iPhone [6-8]'
--Відповідає таким значенням як iPhone 6, iPhone 7 або iPhone8

--WHERE ProductName LIKE 'iPhone [^7]%'
--Відповідає таким значенням як iPhone 6, iPhone 6S або iPhone8. Але не відповідає значенням "iPhone 7" та "iPhone 7S"

--WHERE ProductName LIKE 'iPhone [^1-6]%'
--Відповідає таким значенням як iPhone 7, iPhone 7S і iPhone 8. Але не відповідає значенням "iPhone 5", "iPhone 6" та "iPhone 6S"

----
SELECT * FROM Products
WHERE ProductName LIKE 'iPhone [6-8]%'

--
SELECT * FROM Products
WHERE ProductName LIKE '%one%'

--##########################################################################################
-- Для зміни вже наявних рядків у таблиці застосовується команда UPDATE . Вона має такий формальний синтаксис:

-- UPDATE имя_таблицы
-- SET столбец1 = значение1, столбец2 = значение2, ... столбецN = значениеN
-- [FROM выборка AS псевдоним_выборки]
-- [WHERE условие_обновления]

--
UPDATE Products
SET Price = Price + 5000

--
UPDATE Products
SET Manufacturer = 'Samsung Inc.'
WHERE Manufacturer = 'Samsung'
--
-- UPDATE Products
-- SET Manufacturer = 'Apple Inc.'
-- FROM
-- (SELECT TOP 2 FROM Products WHERE Manufacturer='Apple') AS Selected
-- WHERE Products.Id = Selected.Id

--##########################################################################################
-- Для видалення застосовується команда DELETE:
-- DELETE [FROM] имя_таблицы
-- WHERE условие_удаления
--
DELETE Products
WHERE Id=9
--
DELETE Products
WHERE Manufacturer='Xiaomi' AND Price < 15000
--
DELETE Products FROM
(SELECT TOP 2 * FROM Products
WHERE Manufacturer='Apple') AS Selected
WHERE Products.Id = Selected.Id

-- Якщо необхідно видалити всі рядки незалежно від умови, то умову можна не вказувати:
DELETE Products
--##########################################################################################